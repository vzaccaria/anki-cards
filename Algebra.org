#+TITLE: Notes
#+AUTHOR: Vittorio Zaccaria
#+LEVEL: 3
#+OPTIONS: H:3
#+BEAMER_HEADER: \input{header.tex}
#+STARTUP: indent 

#+TAGS: noanki(n) focus(f)

* Abstract Algebra 
** Other structures
*** Magma                                                                 :noanki:
    A magma is set $M$ equipped with a single binary operation,
    $(*): M \times M \rightarrow M$ that satisfies:

   - *closure*: $a \in M, b \in M \rightarrow a * b \in M$

*** Indexed families 

A /family of elements of $X$ indexed by $I$/ is a function $$f: I \mto X$$ It 
can be written as $$(x_i)_{i\in I}$$ An $n$ -tuple of set $X$ is one such special
function $$(x_i)_{i = \{1 \ldots n\}}$$

*** Lattice

A lattice is a poset where *all objects* have a *meet* (GLB) and a *join* (LUB). 
In a lattice, meets and joins: 

- are idempotent, commutative and associative operations 
- determine the same partial ordering $\leq$ (they are compatible).

*** Subgroup lattice

Given a group $G$, we can order subgroups; each pair of them has a largest
common subgroup (intersecting the underlying sets) and a smallest subgroup
containing both (generated by the union of the underlying sets).

*** Closure operator (posets)                                       :focus:

Given a poset $P$, the closure operator is an endomorphism $cl: P \mto P$ such 
that:
- $x \leq y \implies cl(x) \leq cl(y)$ (functor)
- $x \leq cl(x)$ (this is the $\eta$)
- $cl(cl(x)) = cl(x)$ (this is the $\mu$)

It is an endofunctor and a monad of a poset when this is interpreted as a category. 

*** Closure operator (example of the power set poset)               :focus:

- Given a set $S$, assume $\mathcal{C} = \{ f_i \}$ ($f_i \in P(S)$) are the
  fixed points of the operator $cl$, i.e. $cl(f_i) = f_i$. Call these /closed
  sets/.

- $\mathcal{C} \subseteq P(S)$ is closed under intersection.

- The closure operator is a function $cl: P(S) \mto C$
  and maps any $s$ to the smallest $f_i$ such that $s \subseteq f_i$.

*** Galois connection                                               :focus:
- It is a sort of weak iso-morphism between posets $C$ and $D$. Categorically,
  it is an *adjunction* between two functors $LR$
- The mapping $RL: C \mto C$ is exactly the *closure operator* of the poset (or the unit of 
  the adjunction). 
- The co-unit $LR: D \mto D$ is called the *kernel operator*.
- An antitone Galois connection is just an adjunction between $D$ and $C^{op}$;
  functors, in this case, are called polarities.

*** Galois connection (least element)                               :focus:
- A poset $X$ has a least element if there is an adjunction (or Galois connection)
  with the singleton poset $1=\{ * \}$ where $* \leq *$.
- An adjunction $(l,r)$ (where $r: 1 \mto X$) then if there exists $* \leq l(x)$
  then $r \leq x$. Since $* \leq l(x)$ this is true for all $x$, then $r$ is the
  least element.

*** Galois connection (meets and join)                              :focus:
- The total $\vee: X \times X \mto X$ is the (lower) adjoint to the duplication
  function $\Delta: X \mto X \times X$, where $X$ is a poset.
- On the other hand, the meet $\wedge$ exists for all $x$ if it is the upper adjoint
  to $\Delta$.

** Monoids
*** Monoid                                                                 :noanki:

   A monoid $(M,*)$ is a *semigroup* with a unit element ($1 \in M$) where the $*$
   operation satisfies:

   - *identity*: $m * 1 = m, \forall m \in M$.

*** Generator set (Monoid)                                                                 :noanki:
    A subset $S$ of $M$ is said to be a generator if all elements $m \in M$
    can be obtained by some kind of *fold* of the elements $s \in S$.

    \[
      \forall m \in M, \exists s_1, \ldots, s_n \in S \textrm{~~s.t.~~} m = s_1 * \cdots * s_n
    \]

*** Free generator set (Monoid)                                    :noanki:

    A subset $S$ of $M$ is said to be a generator if all elements $m \in M$
    can be obtained by a *unique fold* of the elements $s \in S$.

    \[
      \forall m \in M, \exists s_1, \ldots, s_n \in S \textrm{~~s.t.~~} m = s_1 * \cdots * s_n
    \]

    Not all generator sets are free. For example, $\{1\}$ is a generator for
    $\mathbb{Z}_n$ but it is not free, in the sense that each element of
    $\mathbb{Z}_n$ can be defined by multiple sequences of 1.

*** Free monoid                                                    :noanki:

    A free monoid is a monoid *with a free generator*.

    - Example: $(\mathbb{N}, +)$ is the *free monoid generated by 1*.

*** Abelian monoid                                                                 :noanki:
    A monoid $(M,*)$ where $$\forall m_1,m_2 \in M, m_1 * m_2 = m_2 * m_1$$

*** Monoid homomorphisms                                                                 :noanki:
    Given two monoids $(X,\star)$ and $(Y, *)$, a homomorphism $$f: (X,\star)
    \rightarrow (Y,*)$$ is a function $f: X \rightarrow Y$ such that:

    \[
      f(1_X) = 1_Y \textrm{~~and~~} f(m \star n) = f(m) * f(n)
    \]

** Groups
*** Group                                                                 :noanki:

   A group $G$ is a monoid where for all elements $a$, the (*) operation satisfies:

   - *closure*: $a \in G, b \in G \rightarrow a * b \in G$
   - *identity element*: $a * 1_G = 1_G * a = a$
   - *invertibility*: $a * a^{-1} = 1$.
   - *associativity*: $a * (b * c) = (a * b) * c$

   In a group, every element has its own inverse.

*** Subgroup                                                                 :noanki:
   $H$ is a subgroup of $G$ if:

   - $H \subseteq G$
   - It is closed under (*).

   The *trivial subgroup* of any group is the subgroup ${e}$ consisting of just the identity element.

*** Normal subgroup                                                                 :noanki:
  - $H$ is a normal subgroup of $G$ iff $$\forall h \in H \wedge g \in G, ghg^{-1} \in H$$

*** Normal subgroup and action of inner automorphisms

- For each $g \in G$, one can define an inner automorphism $i_g(x) = g x g^{-1}$
- A normal subgroup $H$ is invariant to the action of the inner automorphisms
  $I(G)$, because, for any $g$, $i_g(h) \in H$.

*** Kernel of a group homomorphism                                                                 :noanki:
    The *kernel* $\textrm{ker}(f)$ of a group homomorphism $f: (G,\star)
    \rightarrow (H,*)$ is a set $K$ such that

    - $K \subseteq G$
    - $\forall k \in K, f(k) = 1_{*}$

*** Kernel of a group hom. with respect to $G$

It is a /normal subgroup of $G$/, because $$\forall g \in G.f(gkg^{-1})=f(g)f(g^{-1})=1_*$$

*** First homomorphism theorem
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
             &                            & 0                                   &                                                               & 0 \\
             &                            &                                     & G/Ker~f \simeq im~f \arrow[rd, "\iota"] \arrow[ru] \arrow[lu] &   \\
             &                            & G \arrow[rr, "f"] \arrow[ru, "\pi"] &                                                               & H \\
             & ker~f \arrow[ru, "\kappa"] &                                     &                                                               &   \\
0 \arrow[ru] &                            &                                     &                                                               &
\end{tikzcd}
#+END_EXPORT
Every morphism $f$ factors into $\iota \circ \pi$ , where $\iota$ is a
monomorphism and $\pi$ is an epimorphism.

*** Coset
- Given a subgroup $(H, \star) \subseteq (G, \star)$, we define the *left coset*
  of $H$ as the orbit of an element $g$ relative to $H$ active by left
  multiplication:
          
                 $$H_g = \{g \star h : h \in H\}$$


*** Orbits in a group $G$ relative to a group $H$

Orbits in $G$ relative to $H$ are disjoint subsets of $G$: $\bigcup_g H_g = G$

*** Subgroup of an abelian group                                                                 :noanki:
    Every subgroup of an abelian group is normal.

*** Coset multiplication                                                                 :noanki:

    Coset multiplication operation: $$Hg_1 * Hg_2 = H(g_1 \star g_2),~~g_1,g_2 \in G$$

*** Factor/quotient group

    - If $H$ is a normal subgroup of $G$, coset multiplication is a group
      operation of a particular group: the *factor (or quotient) group*.

    - The factor group $G/H$ is a group where elements are the
      cosets of $G$ by $H$ and group operation is cosets multiplication.

*** Construct a quotient group $Z/6Z$.                                                                 :noanki:


    - $(G, +) = Z$
    - $(H, +) \subseteq (G,+) = 6Z$ is the subgroup of all multiples of 6 in $Z$
    - *elements* of the quotient group are all the unique cosets $$H_g = \{ 6Z + g, g \in Z \}$$
      (their elements are infinite, but there are only 6 of them, $H_1=H_7=\ldots$).
    - the *operation* among cosets $$Hg_1 + Hg_2 = H_{g_1 + g_2}$$  respects
      the quotient group properties.

    This quotient group is also called *the cyclic group $Z_6$*.

*** Fundamental homomorphism theorem

    - Given a quotient group $G/H$, there is a homomorphism $\mu: G \rightarrow
      G/H$. This homomoprhism is called 'natural' and corresponds to assigning
      to each $g$ its coset $H_g$.

    - Given any homomorphism $\phi: G \rightarrow Q$, the following sequence is
      exact: $$ 1 \rightarrow N \rightarrow^{\iota} G \rightarrow^{\phi} [Q \cong G/N]
      \rightarrow 1 $$ where $N$ is normal.

*** Semigroup

    A semigroup $S$ is a group *without inverse and identity element*.

   - *closure*: $a \in G, b \in G \rightarrow a * b \in G$
   - *associativity*: $(a * b) * c = a * (b * c),~~a,b,c \in G$.

*** Group identity and inverse properties                                                                 :noanki:

    Both the identity and the inverse of every element are *unique*.

*** Endomorphism ring of an abelian group

    Given a group $(G,+,0_G)$, we can define a set
    \[
      End(G) = \{ f: G \rightarrow G | f(a + b) = f(a) + f(b) \}
    \]

    The set $End(G)$ can be made into a *ring* with the following
    operations/properties

    - sum: $(f ++ g)(x) = f(x) + g(x)$
    - sum unit: $f = x \mapsto 0$
    - sum inverse: $f^{-1}x = (f x)^{-1}$
    - multiplication: $(f \circ g)(x) = f(g(x))$
    - multiplication unit: $f = x \mapsto x$

*** Order of a group element
    In a group, the least integer $n$ such that $a^n=1_{*}$, then that element
    has order $n$.

*** Cyclic group
    If $G$ has an element $a$ and all its elements are powers of $a$, then $G$ is cyclic:
    $$G = \{ a^n : n \in Z \}$$

    $a$ is called generator and the group order is the order of $a$.

*** Symmetric group                                                                 :noanki:
    The symmetric group $S_n$ is the group of all permutations (symmetries) of $\{1, . . . , n\}$

*** Group action                                                                 :noanki:

     - A group action $\phi$ of group $G$ on a set $X$ is a function
       $$*: G \times X \rightarrow X$$ satisfying the following properties:

       - identity: $e * x = x$
       - compatibility: $(gh) * x = g * (h * x)$

     - An action $g * x$ is the same as a group homomorphism $G \rightarrow \textrm{Aut}(X)$

*** Group action (categoric view)
     - A group action from $G$ into $S$ is a functor $BG \rightarrow Set$ ($BG$ is the  
      one object category). 

    - The existence of a functor implies that the morphisms $g_*$ in $Set$ are 
      automorphisms that have an inverse and that $(g_*)^{-1} = (g^{-1})_*$.


*** Commutator subgroup                                                                 :noanki:

   - A commutator subgroup $[G,G]$ is an abelian group that can be built from a
     finite group $G$.

   - It is composed of the set of elements $$[G,G] = \{ xyx^{-1}y^{-1}, x~y \in G \}$$

   - It is a normal subgroup

*** Commutator subgroup of $S_n$                                                                 :noanki:

    The commutator subgroup of $S_n$ is the alternating group $A_n$. It
    is the set of all even permutations in $S_n$. Even = even number of
    transpositions in which it can be written.

*** Subgroup index

  - The index of a subgroup H in G is defined as the number of cosets of H in G
    (it is the number of partitions).

  - It is denoted as $[G:H]$.



*** Isotropy group (group stabilizers)
    - Given a group $H$, a set $S$ and an action $\curvearrowright: H \times S
      \rightarrow S$, a *stabilizer* of $s \in S$ is an element $h_s \in H$ such
      that $$ {h_s} \curvearrowright s = s$$
    - For each $s \in S$ one can define a group $Stab_H(s) = \{ h_s \}$ which is a
      sub-group of $H$ (it is called /isotropy group/).

*** Orbit in a set $S$ relative to a group $H$
:PROPERTIES:
:BEAMER_opt: fragile
:END:
#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                                                               & (h_0 \curvearrowright s) \in S  \arrow[ld, no head, dotted, bend right]              &                                                           \\
h_1 \curvearrowright s \arrow[rd, no head, dotted, bend right] & s \in S                                                                              & h_{|H|} \curvearrowright s \arrow[lu, dotted, bend right] \\
                                                               & h_2 \curvearrowright s \arrow[ru, "\ldots" description, no head, dotted, bend right] &                                                          
\end{tikzcd}
#+END_EXPORT
#+END_CENTER
- Given an action $\curvearrowright: H \times S \rightarrow S$ the *group orbit*
  of $s \in S$ is a subset of $S$ defined as $$H_s = \{h \curvearrowright s:
  \forall h \in H \}$$

- Orbits are disjoint subset of $S$: $\bigcup_s H_s = S$ and define an $H-$ 
  equivalence relation over $S$.

*** Invariance relative to a group $H$                             :noanki:

- An element $t \in S$ is /invariant/ relative to $H$ if the orbit associated to
  it is a singleton: $$H_t = \{ t \}$$

- A subset $\{ t \} \subset S$ is invariant relative to $H$ if $H_t \subset \{ t
  \} \forall t$


# - $Orb(s)$ forms a group which is isomorphic to $G/Stab(s)$.

*** Orbit-stabilizer theorem

- Remember that $Stab(s)$ is a subgroup (isotropy group) of $H$; thus one can talk 
  about the cosets of $Stab(s)$ in $H$, so we have:

    $$|H_s| = [ H : Stab(s) ]$$

*** Centralizer of a group element
    The centralizer of an element $a$ of a group $G$ is the set of elements of
    $G$ that commute with $a$: $$C_G(a) = \{ g \vert ga = ag \}$$

*** Group conjugacy classes
    - Two elements $x, y$ of a group $G$ are conjugate-wise equivalent if $$\exists g. y=gxg^{-1}$$
    - The conjugacy class of an element $x \in G$ is the set of elements:
      $$Cl(x) = \{ gxg^{-1}: g \in G \}$$
*** Set of conjugates  and conjugate closure
Given a group $G$ and a subset $S$, the set of conjugates is 
$$ S^G = \{ g^{-1} s g \}$$
The conjugate closure of $S$ is indicated with $\ang{S^G}$ the subgroup of $G$ generated by $S^G$. 
It is the smallest \emph{normal} subgroup of $G$ that contains $S$.

*** Class number of a group $G$

    - The class number of G is the number of distinct (nonequivalent) conjugacy classes
*** Free group construction                                         :focus:
The free group $F_S$ with free generating set $S$ can be constructed as follows.
- Consider $S$ is a set of symbols and define for every $s \in S$ a
  corresponding $s^{-1} \in S^{-1}$. 
- Let $T = S \bigcup S^{-1}$, and define a *word* be the free monoid generated by $T$.
- The free group $F_S$ is the group of all reduced ($\forall x. xx^{-1} \rightarrow
  \cdot$) words in $T$ with *concatenation* as group operation.
This construction is a *functor*.

*** Free group universal property                                   :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
- A *free group* $F_X$ on the set $X$ is a universal arrow from $X$ to the group forgetful
  functor. It is a pair $(F_X, u)$ such that for any function $v: X \mto |G|$, 
  there is a unique group homomorphism $f$ for which the diagram below commutes. 

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                                         & X \arrow[ld, "u",red] \arrow[rd, "v"] &  \\
\vert F_X \vert \arrow[rr, "\vert f \vert"]                 &                                         & \vert G \vert \\
F_X \arrow[rr, "f"] &                                         & G \\
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


*** Group automorphism

- It is a morphism $\alpha: G \rightarrow G$ that respects multiplication:
  $$\alpha(g_1g_2) = \alpha(g_1)\alpha(g_2)$$

*** Group automorphisms' group 

- The set $A(G)=\{ \alpha \}$ is a subgroup of $P(G)$, i.e., the group of
  permutations of $G$ elements.

*** Inner automorphisms
- For each $g \in G$, one can define an inner automorphism $i_g(x) = 
  g x g^{-1}$

- These automorphisms are permutations that form a group $I(G) \subset A(G)$.

*** Center of a group
- The center of a group $G$ is $$C(G) = \{ g: \gamma g = g \gamma, \forall \gamma\}$$

*** Center of a group as a kernel 

- It is the kernel of the homomorphism $G \rightarrow I(G)$: $$g \mapsto (\gamma
  \mapsto g \gamma g^{-1})$$ because all the elements in the center are mapped to 
  an identity.

- So, by the FHT, $I(G) = G/C(G)$
 
*** Group theoretic term and n-ary operations
- A *group theoretic term* $t_X$ is a formal expression using formal group
  operations $(\cdot, ^{-1}, e)$ and a set of symbols $X=\{x,y,z\}$.

- The above identifies a group element once one is given a function $f: X
  \mto |G|$ (or $f \in |G|^X$). The set of group theoretic terms $T_X$ and $|G|^X$
  are endowed with a unique evaluation map $$ev: T_X \mto |G|^X \mto |G|$$

*** Group theoretic relation
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- A /group theoretic relation/ is a subset of $T_X \times T_X$ composed of all
  pairs $(t_1, t_2)$ such that $\exists s. ev(t_1, s) = ev(t_2, s)$. 

- It is a projection (into $GR_X = T_X \times T_X$) of the pullback $R$: 

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  GR_X & R_{X} \arrow[d] \arrow[r] \arrow[l] & T_X \times S \arrow[d, "ev \& id"] \\
      & T_X \times S \arrow[r, "ev \& id"'] & G \times S
  \end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

- Note for
  example that $(ab)'=b'a'$ for all elements of a group but only some elements
  satisfy $ab = ba^2$.



*** Group theoretic relations and free group construction

- A /free group/ on set $X$ is the set of equivalence classes on $T_X$ (the set of
  group theoretic terms) of group theoretic relations, i.e. $$T_X/R_X$$
  
- Remember that $R_X$ is a pullback of $ev \& id$: $$R_X = (T_X \times S)
  \times_{G \times S} (T_X \times S)$$

- Given $[t]$ as the equivalence class of $t \in T_X$ we have that:
   $$[p][q] = [pq], [p]^{-1} = [p^{-1}],~ e = [e]$$




*** Derived operations on groups

- Given a set $X$ of $n$ elements, fixing $t \in T_X$ (the set of group
  theoretic terms), one gets a /substitution/ $$s: |G|^n \mto |G|$$ called *derived
  $n$ -ary operation* of $G$ (or /term operation/).

- Examples: 

  - $t_{x,y} = y^{-1}xy$ provides a substitution called /conjugation/
  - $t_{x,y} = x^{-1}y^{-1}xy$ provides /commutator/
 
- Note that given two group theoretic terms one can have the same substitution;
  for example $(x \cdot y) \cdot z$ and $x \cdot (y \cdot z)$ are the same for
  groups.

*** Omega algebra

- Let $\Omega$ be a pair $(|Omega|, n)$ where $|\Omega|$ is a set of symbols
  $\omega$ representing operations and $n: |\Omega| \mto \NN$ associates an
  arity to each operation $\omega$.

- An $\Omega$ algebra is a tuple $(|A|, (\alpha_{\omega})_{\omega \in |\Omega|}))$ where
  $$\alpha_{\omega} : |A|^{n(\omega)} \mto |A|$$

** Group representations
*** Category of linear representations                                                                 :noanki:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Assume $BG$ is the category with one object associated with group $G$. The category
of representations $Rep(G)$ is the functor category $Vect^{BG}$ where
- objects are functors $BG \rightarrow Vect$ and correspond to representations $\rho$
- morphisms are natural transformations $\Phi$ (with a single component $\phi$).

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\bullet \arrow[d, "g_1", bend right] \arrow[r, "\rho_E", dotted] \arrow[rrr, "\rho_F", dotted, bend left] & E \arrow[d] \arrow[rr, "\phi_E"] & * \arrow[d, "\Phi", dashed] & F \arrow[d] \\
\bullet                                                                                                   & E \arrow[rr, "\phi_E"']          & *                           & F          
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Properties of a linear group representation                                                                 :noanki:

    - $\rho_g \rho_h = \rho_{gh}$
    - $\rho_1 = Id$
    - $(\rho_g)^{-1} = \rho_{g^{-1}}$
    - $\rho_g(xv + yw) = x\rho_gv + y\rho_gw$

*** Permutation representation                                                                 :noanki:
     - The *permutation representation* is the representation of a symmetric group
       $S_n$ acting on $V_k = k^n$.
     
     - It gives the following permutation matrix for each $s \in S_n$, i.e., 
       if $v \in V_k = \sum_j a_j e_j$: $$\rho_s
       v = \sum a_j e_{s(j)}$$


*** Character of a representation

    - The *character* of a representation $\rho$ is the trace of the corresponding
      matrix: $\chi_{\rho_g} = Tr(\rho_g)$.

    - Frobenius showed there is finitely many irreducible representations of G
      and that they are completely determined by their characters.

    - The character is a central or class function, it depends only on the
      conjugacy class of $g$.

*** Properties of the character of a representation

    - $\chi_{\rho}(1) = dim(\rho)$
    - $\chi_{\rho \oplus \sigma} = \chi_{\rho} + \chi_{\sigma}$
    - $\chi_{\rho \otimes \sigma} = \chi_{\rho} * \chi_{\sigma}$
    - $\chi_{\rho^*}(g) = \chi_{\rho}(g^{-1})$

    If $k=C$, $\chi_{\rho}(g)=\bar{\chi}_{\rho}(g^{-1})$

*** Conjugacy classes and irreducible representations
    - The number of isomorphism classes of irreducible representations of G
      equals the number of conjugacy classes of G.
    - The size of these representations is given by the Maschke's sum of squares

*** Orthogonality relations
    Given the space of functions $F = \{ f: G \rightarrow k \}$, define the
    averaging operator $$(f_1,f_2) = \frac{1}{|G|}\sum_G f_1(g^{-1})f_2(g)$$

    - Assume $(\rho, V)$ and $(\sigma, W)$ be irreducible representations of a
      group. If they are not isomorphic then $(\chi_{\rho},\chi_{\sigma}) = 0$.
      If they are equivalent then $(\chi_{\rho},\chi_{\sigma}) = 1$

    - $dim(V^G) = (\chi_{\rho}, \chi_{triv})$
*** Sign representation                                                                 :noanki:
    Given any representation of the permutation group $\rho(S_n)$,
    $\textrm{det}(\rho(S_n))$ is the corresponding sign representation as well
    and it is either 1 or -1.

*** Faithful representation                                                                 :noanki:

    A *faithful* representation $\rho$ is an *injective* map, i.e., different $g$
    are represented by distinct $\rho(g)$.

*** Unitary representations                                                                 :noanki:

    - Assume $V$ is a space equipped with a hermitian dot product (on $C_2$)
      that measures the distance between vectors (i.e., an Hilbert space).

    - $(\rho,V)$ is unitary (or, a unitary operator) if it preserves the
      distance of vectors ($\langle\rho(g)v,\rho(g)w\rangle = \langle v,w
      \rangle$).

    - If the group is finite, then one can always build an unitary operator.


*** Invariant representation                                                                 :noanki:
     A representation $\rho(g)$ is *invariant* if $\forall v \in V. \rho(g)v \subseteq V$

*** Intertwining operator                                                                 :noanki:

  - An intertwining operator is a natural transformation between 
    representations interpreted as functors from $BG$.

 - Two representations are equivalent if there exists a natural isomorphism between
   the corresponding functors.

*** Subrepresentations
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given $E \subseteq F$, a representation $(\rho_E,E)$ is a sub-representation of
$(\rho_F,F)$ if $\rho_F \circ i = i \circ \rho_E$ (i.e., the inclusion map is
an intertwiner):

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\bullet \arrow[d, "g"] \arrow[r, dotted] \arrow[rrr, dotted, bend left] & E \arrow[d, "\rho_E(g)"] \arrow[rr, hook] & * \arrow[d, "\Phi", dashed] & F \arrow[d, "\rho_F(g)"] \\
\bullet                                                                 & F \arrow[rr, hook]                        & *                           & F                       
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


*** Trivial subrepresentation
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\bullet \arrow[d, "g"] \arrow[r, dotted] \arrow[rrr, dotted, bend left] & F^G \arrow[d, "\rho_{F^G}(g) \simeq I"] \arrow[rr, hook] & * \arrow[d, "\Phi", dashed] & F \arrow[d, "\rho_F(g)"] \\
\bullet                                                                 & F^G \arrow[rr, hook]                                     & *                           & F                       
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

A trivial subrepresentation $F^G$ is an identity map that is intertwined by inclusion.

*** Functoriality of representations

For any endo-functor $T$ in **Vect**, a representation $\rho$ of on a space $E$ can be used 
to derive a representation $\pi = T\rho$ on $TE$.

*** Irreducible representation

    An *irreducible* representation $(\rho,V)$ has as subrepresentations only
    $(\rho,0)$ and $(\rho,V)$

*** Maschke's theorem
    Given two representations of group $G$: $(\rho,V), (\rho, W), W \subset V$ we have
    $$|G| \nmid char(k) \leftrightarrow \exists W'. V = W \oplus W'$$

*** Maschke's sum of squares

    If $V = \bigoplus V_i$ and all $V_i$ are irreducible representations of $G$,
    then $$|G| = \sum_i dim(V_i)^2$$.

*** Full reducibility                                                                 :noanki:

    If $V = W_1 \oplus \ldots W_n$ and all $(\rho, W_i)$ are irreducible then
    $(\rho, V)$ is fully reducible.

*** Representations of Abelian groups                                                                 :noanki:

    - For an abelian group, it is possible to choose a basis to make $\rho(g)$ diagonal.

    - For G finite, matrices are going to be block diagonal.

*** One dimensional representation                                                                 :noanki:

  - A one-dimensional $k$ representation is built above a homomorphism $\chi: G
    \rightarrow k^{\times}$ and corresponds to a representation $\rho_k(g) =
    \chi(g)Id_{V}$ ($\chi(\cdot)$ is in fact a scalar).

  - The set $\hat{G}$ of one-dimensional representations of a group $G$ is an
    abelian group and it is isomorphic to $G/G'$ where $G'$ is the
    commutator subgroup.

*** Representations of external direct sums                                                                 :noanki:

   - An external direct sum $V \oplus V'$ is the set of pairs that can be built

   - $\rho_{\oplus}(g)(v,v') = (\rho(g)v, \rho'(g)v')$

   - Practically, if we concatenate $v,v'$ in a single vector, $\rho_{\oplus}$
     is a diagonal block matrix of $\rho, \rho'$.

*** Representations of dual spaces                                                                 :noanki:

    Given $(\rho,V)$, one can define a representation of its dual vector space
    $(\rho^*, V^*)$ such that $$\rho^*(g) \vec{f} = v \mapsto f (\rho^{-1}(g)
    \cdot v)$$.

*** Representation of quotient spaces.                                                                 :noanki:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
F \arrow[d, "\rho(g)"] \arrow[r, "i", hook] & E \arrow[d, "\rho(g)"] \arrow[r, "\phi"] & H = E/F \arrow[d, "\rho_h(g)"] \\
F \arrow[r, "i", hook]                      & E \arrow[r, "\phi"]                      & H                             
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Assume $\phi: E \rightarrow E/F$ the canonical map of $E$ into its quotient
vector space $E/F$ and that $(\rho,F)$ is a subrepresentation of $(\rho,E)$. 
Then we can say that: 

- $i: F \rightarrow E$ is a morphism of representations 
- $\phi$ is a morphism of representations $\rho \rightarrow \rho_h$.

In general, the kernel and the image of a morphism between spaces $E_1
\rightarrow E_2$ are subrepresentations of the $E_1$ and $E_2$ respectively.

 



*** Kernel representations                                                                 :noanki:
    
    - Given a homomorphism $\mu$ between spaces $E_1 \rightarrow E_2$, the
      representation $E_1/Ker(\mu)$ is isomorphic to $Im(\mu)$

*** Representation of a tensor product space                                                                 :noanki:

    Given $(\rho, V)$ and $(\rho', V')$, one can define
    $$(\rho_{\otimes},V \otimes V') = \rho v \otimes \rho' v'$$

    If input repr. are one-dimensional, tensoring becomes multiplication.

*** Representation of $Hom$ spaces                                                                 :noanki:

    Given $Hom_C(V, V') = \{ f: V \rightarrow V' \}$ linear, one can define
    a representation from representations of $V$ and $V'$:

    $$\rho_{Hom} f = \rho' \circ f \circ \rho^{-1}$$

*** Representation of conjugate vector spaces                                                                 :noanki:
    Given $(\rho,V)$, $\rho$ is a representation of the
    conjugate vector space $\bar{V}$ as well.

    A conjugate representation $(\rho, \bar{V})$ is *equivalent* to $(\rho, V)$
    and to its dual representation $(\rho^*, V^*)$.

*** Regular representation of $G$                                                                 :noanki:

    A group algebra $K[G]$ is a vector space of elements $\phi$ that can be written as
    $$\phi: \phi(g_1)g_1 + \phi(g_2)g_2 + \ldots$$ i.e., $$K[G]=span\{g_1, g_2,
    \ldots \}$$ The regular representation $(\rho_{K}, K[G])$ is such that
    $$\rho_{K}(s)\phi = \rho_{K}(s) \phi(g_1)g_1 + \ldots = \phi(g_1)(s*g_1) +
    \ldots$$

    See nb. 4 - p. 28

*** Regular representation of $G$ through Cayley                                                                 :noanki:

    - By Caley, there is an isomorphism $\rho_C: G \rightarrow S_n$ for a group
      $G$ of order $n$ that is given by picking a permutation $\lambda x.gx$.

    - A regular representation is just the concatenation of a permutation
      representation and the cayley isomorphism: $$\rho = \rho_{\pi} \circ
      \rho_{C}$$ In practice, it associates a permutation to each $g \in G$.

    - For example, the regular representation of a cyclic group of order $n$
      ($\{1,x,x^2,\ldots, x^n\}$) associates to each element the power of a
      cyclic permutation matrix $P$.

*** Representation of function space over $G$                                                                 :noanki:

    A function space $F(G) = \{ \phi: G \rightarrow K \}$ can be seen as composed
    of members of the group algebra (similarly to the Z-transform): $$\phi:
    \phi(g_1)g_1 + \phi(g_2)g_2 + \ldots$$ i.e., $$K[G]=span\{g_1, g_2, \ldots
    \}$$ thus one can define a representation that is equivalent to the group
    algebra's one.

*** Schur's lemma                                                  :noanki:
     - If $(\rho, V)$ and $(\rho', V)$ are irreducible representations and there
       is an intertwining operator $L$, *then* $$L \neq 0 \rightarrow L
       \textrm{~is an equivalence}$$ (no middle ground).
*** Schur's lemma - corollary for $L : V \rightarrow V$            :noanki:
     For irreducible representations ($\rho,V$) all intertwining operators $L: V
     \rightarrow V$ have the form $L=\lambda I$ where $\lambda$ is a scalar. In
     fact, $\lambda$ is the root of the characteristic polynomial (an
     eigenvalue) of $\phi$.
*** Schur's lemma - corollary for $L_1, L_2$ intertwining operators :noanki:
     For irreducible representations ($\rho, V$) and ($\rho', V'$) all the intertwining
     operators have the form $L_1 = \lambda L_2$.
*** Irreducible representations of abelian groups                                                                 :noanki:
    - All irreducible representations $(\rho, V)$ of an abelian group are such that
      $dim(V)=1$ (by Schur's lemma), i.e., they are one dimensional.
    - To each $\rho(g)$ it corresponds a scalar $\lambda_g$, which is called *character*.
    - If $\rho$ is not irreducible, then there exists a basis such that
      $\rho(g)$ is diagonal.

*** Multiplicative group of roots of unity

Set of points whose angles are a rational multiples of $\pi$:
$$\mathbb{T} = \{ \forall kn. e^{2\pi i k/n}\}$$

*** Dual group
 - The dual group of $G$ (i.e., $\hat{G}$) is the set of all homomorphisms from
   $G$ into $T$, the multiplicative group of all roots of unity, i.e.:
   $$\hat{G} = Hom(G,\mathbb{T})$$
 - Functions in $\chi \in \hat{G}$ are called *characters* on the group (which are
   not, in general, the characters of the representation) and multiplication in
   $\hat{G}$ is the multiplication of characters.
 - Just as $K$ represents the functor $(-)^V$, $\mathbb{T}$ represents $(-)^G$
   and the set is just the dual group.

*** Dual group examples
| Name                     | Parameterized element     | Parameter range                                     |
|--------------------------+---------------------------+-----------------------------------------------------|
| $\hat{\mathbb{Z}}$       | $z \mapsto t^z$           | $\forall t \in \mathbb{T}$                          |
| $\widehat{\mathbb{Z}/n}$ | $z \mapsto (\xi_n^{t})^z$ | $\forall t \in \{0 ... n-1\}, \xi_n = e^{2\pi i/n}$ |
| $\hat{\mathbb{R}}$       | $r \mapsto (e^{i t})^r$ | $\forall t \in \mathbb{R}$                   |

$\xi_n$ is the n-th root of unity (i.e., $\xi_n^n = 1$)

*** Group representations and modules                               :focus:
- If $G$ acts on $V$ through $\rho: G \mto V^V$, then also $KG$ acts on $V^V$ 
  K-linearly:
  $$\left(\sum_{g\in G} a_g g\right) v:=\sum_{g\in G}a_g(g\cdot v) \qquad \forall v\in V, ~a_g\in k.$$
  so there is a ring hom: $$KG \rightarrow_{Ring} V^V$$ 
- Since a module is a ring homomorphism into $V^V$ then a representation
  induces automatically a $KG-module$ and viceversa.
- For example, irreducible representations of $G$ correspond to simple $KG$ -modules.
*** Fourier transform of a group

- It derives from the Peter-weyl theorem that states that $C[G]
  \simeq \bigoplus_i GL(V_i)$ where $V_i$ are the irreducible representations of $G$.

- The Fourier transform is just this isomorphism.

- Given a function $f: G \rightarrow \mathbb{C}$ and a representation $\rho(g)$ of
  $G$ over $\mathbb{C}$, we define the transform as: $$\hat{f}(\rho) = \sum_{g\in
  G}f(g)\rho(g)$$

  Note that since $\rho$ is a matrix of dimension $d \times d$, also $\hat{f}$ is
  a matrix $d \times d$.
   
*** Inverse Fourier transform of a group
Given a transform $\hat{f}: GL(\mathbb{C}) \rightarrow \mathbb{C}$, the original
function can be derived from all its original representations: 
$$f(g) = \frac{1}{|G|}\sum_i d_i\textrm{Tr}(\rho_i(g^-1)\hat{f}(\rho_i))$$
where $d_i$ is the dimension of each representation


*** Fourier transform of Abelian groups
If $G$ is an abelian group:

- all $\rho_i$ are monodimensional and they correspond to the irreducible
  characters $\chi_i$ of the group.

- these characters form a group structure $\hat{G} := Hom(G, \mathbb{T})$ (called the
  Pontryagin dual of $G$)

- the original function $f$ over the group can be re-written as: 
  $$f(g)={\frac {1}{|G|}}\sum_{\chi_i}{\widehat {f}}(\chi_i)\chi_i (g)$$

  which means that $f$ can be constructed from its base characters $\chi_i$.

*** Fourier transform of the quotient group $\mathbb{Z}/n$

For $G=\mathbb{Z}/n$, we have $n$ irreducible representations that can be
"generated" $k\in Z$: $$\chi_k(z)=z \mapsto e^{k\frac{2i\pi}{n}z}$$

** Topological group
*** Topology

Given a set $X$ and a function assigning a set of subsets $\mathbf{N}(x) = \{ N_k
\subseteq X\}$ to each $x \in X$ we call $(N,X)$ a topological space if

- $\forall x\forall N_k. x \in N_k$ 
- $N_i \subseteq N_j \wedge N_i \in \mathbf{N}(x) \implies N_j \in \mathbf{N}(x)$
- $N_i \cap N_j \in \mathbf{N}(x)$
- $N_i  = \{ \ldots e \ldots \}$ $N_i \subseteq N_j \implies N_j \in \mathbf{N}(e)$.

  
** Semirings
*** Semiring (Rig)
    A semiring $R$ consists of a set $R$ such that:

    - $(R, +)$ is a commutative monoid with identity = 0 (note, *not a group*, it
      should not have an inverse).
    - $(R, *)$ is a monoid with identity = 1
    - multiplication distributes over addition
    - multiplication by 0 gives 0 (annihilates).

** Rings
*** Ring                                                           :noanki:

    A ring $R$ consists of a set $R$ such that:

    - $(R, +)$ is a *commutative* *group* with identity=0 (note that it should have
      an inverse, so we can talk about *negative* values).
    - $(R, *)$ is a monoid with identity = 1 (Semigroup)
    - multiplication distributes over addition
    - multiplication by 0 gives 0 (annihilates).

*** Commutative ring                                               :noanki:

   A commutative ring $R$ is commutative if $(R, *)$ is commutative.

*** Ring divisor of zero                                           :noanki:
    - $a \neq 0$ is called divisor of zero if there is $b \neq 0$ such that $ab = 0$

    - Z,Q,R and C do not have divisors of zero. This means that, if the product
      of two numbers is zero, then one of them should be zero.

*** Ring cancellation property                                     :noanki:

    - A ring has cancellation property if and only if it doesn't have divisors
      of zero. Equationally: $$ ab = ac
      \rightarrow b = c $$

*** Integral domain                                                :noanki:
    - It is a commutative ring (with multiplication commutative) that has the
      cancellation property.

    - An integral domain with non-zero characteristic $p$ is such that $p$ is prime.

*** Integral domains and fields                                    :noanki:

    - Every field is an integral domain.

    - Every *finite* integral domain is a field, because you can find a
      multiplicative inverse for each element of the field (this depends on the
      fact that there are no zero divisors).

    - A *finite integral domain* is just a *finite field*

*** Quaternions

    - The set of $H$ quaternions is a 4-dimensional vector space over $\mathbb{R}$.

    - As it can be equipped with a multiplication (Hamiltonian mult.), it is
      a $k$ *algebra* (which is non-commutative).

    - It is possible to divide quaternions so they form a division algebra

    - The basis form a group under multiplication which is called quaternion group.

    - In the terminology of abstract algebra, there are injective homomorphisms
      from $H$ to the matrix rings $M(2, C)$ and $M(4, R)$


*** Subring                                                                 :noanki:

    If $S \subseteq R$ ($R$ is a ring) and $S$ is closed under sum, difference
    and multiplication of $R$, then it is a subring of $R$.

*** Ideals                                                                 :noanki:
    A subring $I$ of $R$ if

    - it absorbs elements of $R$ by multiplication: $$\forall s \in I, \forall r
      \in R. sr \in I$$
    - it is closed under addition.

    For example, even integers (but not the odd) are an ideal of $Z$.



*** Principal ideal

    A /principal ideal/ can be generated by taking an element $s$ of a commutative
    ring $R$ and computing the set $$ \langle s \rangle = \{ s * r: r \in R \}$$

    It can be shown that it respects the ideal properties (closed under addition
    and difference and absorbs multiplication).

    Every ideal in $Z$ is principal, but there are cases where an ideal is not principal.

*** Maximal ideal
- $I$ is a maximal ideal of a ring $R$ if there are no other ideals contained
  between $I$ and $R$.

- Quotient rings $R/I$ of maximal ideals are fields (when $R$ is unital, i.e.,
  there exists a unit for all the elements in $R$).

*** Prime ideal 

A prime ideal $P$ of a ring $R$ is such that, if $a$ and $b$ are two elements of
$R$ such that their product $ab$ is an element of $P$, then $a$ is in $P$ or $b$
is in $P$.

For integers, a prime ideal is the set that contains all the multiples of a
given prime number,

*** Ring homomorphism                                                                 :noanki:

    If $R$ and $S$ are rings, a ring homomorphism $f: R \rightarrow S$ is a
    total function such that:

    - $f(a + b) = f(a) + f(b)$
    - $f(a * b) = f(a) * f(b)$
    - $f(1_R) = 1_S$

*** Ring anti-homomorphism

    If $R$ and $S$ are rings, a ring anti-homomorphism $f: R \rightarrow S$ is a
    total function such that (note that multiplication order is inverted):

    - $f(a + b) = f(a) + f(b)$
    - $f(a * b) = f(b) * f(a)$
    - $f(1_R) = 1_S$

*** $\ZZ$ ring homomorphism

For every ring $R$, there is a unique ring homomorphism $\ZZ \rightarrow R$. This says that the
ring of integers is an initial object in the category of rings.

*** Kernel of a ring homomorphism
    The kernel of a ring homomorphism $f: R_0 \rightarrow R_1$ is a subring
    $$I_R = \{ k \in R | f(k) = 0$$ which is ideal, because $f(a*k) = f(a)*f(k)$
    so if $k \in R$ then also $a*k \in R$. 
*** Cosets of an ideal of a ring

    A coset of an ideal $I_a$, just as those of subgroups, is created with the
    addition operation as in group theory: $$I_a = \{ a + i | i \in I\} a \in
    R$$ We can define both addition and multiplication:

    - $I_a + I_b = I_{a + b}$
    - $I_a * I_b = I_{a * b}$

    An ideal of a ring is actually a *subring*. Given a ring R and a subring I,
    you can form the quotient ring R/I if and only if I is an ideal.

*** Ring center

    The center of a ring $R$ is the subring $Z(R)$ of the elements $z$ such that $$zy
    = yz$$ for all elements $y$ in R.

*** Quotient ring

    Given a ring $R$ and an ideal $I$, the set of cosets of $I$ is a ring and
    it is called the quotient ring $R/I$.

*** Division ring
    - A ring where every nonzero element a has a multiplicative inverse.
    - Also called *skew field*, they differ from fields because multiplication is
      not required to be commutative.
*** Integral system                                                                 :noanki:
    - An integral domain $A$ that is *ordered* and for which every subset $B \subseteq
      A$ has a *least element* (initial object)
    - The above property ensures that there are no elements $c$ such that $0<c<1$.
    - Every element is a multiple of 1.
*** Integral system - mathematical induction                                                                 :noanki:
    If the following condition hold for a subset $K$ of an ordered integral system:
    - $1 \in K$
    - $k \in K \Rightarrow (k+1) \in K$
    then $K$ is all the integers. Proof by contradiction (see Pinter).

*** Polynomial                                                     :noanki:
    - Take a ring $Z$ and add a new symbol $\pi$. Which other numbers should be
      present to make it a ring? It turns out that all the numbers of the form
      $$a_n \pi^n + \dots + a_1 \pi + a_0$$ should be present.
    - The ring created is the polynomial ring $\mathbb{Z}[x]$.

*** Ring of a polynomials over a field: ideals 
    Every ideal of a polynomial ring $\mathbb{F}$ is *principal*, i.e., ideals are
    always of the form $$\langle s(x) \rangle = \{ s(x) * f(x): f(x) \in \mathbb{F}(x) \}$$

    Any ideal $J$ is generated by its member $s(x)$ of the lowest degree.

*** Polynomial associates                                          :noanki:
    Two polynomial $a(x), b(x) \in F[x]$ are associates if there exists an
    element $c \in F$ such that $a(x) = c \times b(x)$. It follows that they
    have a unique monic greatest common divisor polynomial.

*** Irreducible polynomials                                        :noanki:
    A polynomial is *reducible* if it is expressible as the product of two other
    polys. It is *irreducible* otherwise. 
    
    For example $x^2+1$ is irreducible over $\mathbb{R}$ but reducible in
    $\mathbb{C}$.

*** Unique factorization domain

    Every polynomial $a(x)$ (with coefficients in $F$) of positive degree can be
    written *uniquely* as: $$a(x) = k p_1(x) \ldots p_n(x)$$ where $p_j(x)$ is a
    monic irreducible polynomial.

    We say that $F[x]$ is a *unique factorization domain*.

*** Semisimple ring
A ring is semisimple if (as its left or right module) is semisimple.
** Fields

*** Field                                                                 :noanki:

    A field a set with two operations:

    - $(F, +)$ is a commutative group
    - $(F, *)$ is a commutative group

*** Field characteristic

    A field has characteristic $n$ if $1_{*}$ summed with it self $n$ times gives
    $0_{+}$.

    The following relation is found to hold: $$ n > 0 \leftrightarrow
    \textrm{prime}(n)$$



*** Field extensions 

    - Assume $\pi(x) \in F[x]$ irreducible. Can I build *a field extension* $F[c]$
      such that $\pi(x) \in F[c][x]$ is reducible? What structure does it pose to
      $F[c]$ and all its polynomials $p_i(c)$?
    - Assume $\sigma_c: F[c][x] \rightarrow F[c]$ substitutes $c$ into all occurrences of $x$ and
      $\pi(x)$ to 0.
    - Then
      - $\pi(c)=0 \in F[c]$ 
      - All other $p_i(c)$ can be written as remainders with respect to the
        division with $\pi(c)$. Their degree will be always less than $\pi(x)$.
    - Another way to see this is that the smallest field that contains $F$ and
      $c$ is isomorphic to the quotient ring $F[x]/<\pi(x)>$
      
*** Degree of a field extension
- An extension $F[c]$ is a vector space that contains $F$ and combines linearly
  its elements with $c$.

- If the dimension of $F[c]$ is $n$, we say that the *degree of $F[c]$ over $F$
  is $n$*, i.e., $$[F(c) : F]=n$$


*** Algebraic element and minimal polynomial
- Given an extension $F$ of a field $K$, $a \in F$ is called an *algebraic
  element* over $K$ if: $$\exists k(x). k(a) = 0$$ where $k(x)$ has coefficients
  in $K$. Otherwise they are called transcendental over $K$. The lowest degree
  polynomial $g(x)$ of such form is called /minimal polynomial/ of $a$.

- Examples: 
  - $\sqrt(2) \in \RR$ is algebraic over $\QQ$ with minimal polynomial $x^2-2$
  - $\pi \in \RR$ is trancendental over $\QQ$, while it is algebraic over $\RR$
  - $i \in \CC$ is algebraic over $\RR$ with polynomial $x^2+1$


*** Algebraically closed field
  
  - An algebraically closed field $K$ contains a root for every non-constant
    polynomial in $K[x]$, the ring of polynomials in the variable $x$ with
    coefficients in $K$.

  - In practice, roots can be found within it, no need for an extension
    introducing new elements that are algebraic and not contained in $K$. Complex
    numbers are an example.

  - Any field has an algebraic extension that is closed

*** Algebraic field extension

- An extension $L$ of $K$ is algebraic if every element of $L$ is algebraic over $K$. 

- $\CC/\RR$ is algebraic because a complex number can be always seen as a root of a polynomial
  with real coefficients.

*** Transcendental field extension

- A field extension $L$ of $K$ is *transcendental* if some element in $L$ are not a root
  of a polynomial in $K$.

- For example, $\RR/\QQ$ is transcendental because it has, for example, $\pi$.

*** Field extension $Z[x]/(x^2+x+1)$
    The polynomial $x^2 + x + 1$ does not have any root in $Z_2$. To
    build the field $Z_2[c]$, first identify the elements, i.e., $(0,1,c)$ and
    $(c+1)$ to make it closed under addition. When you build the
    multiplication table, remember to elide any addend of the type $c^2+c+1$.
*** Field extensions as vector space
    - An extension $F(c)$ can be seen as a vector space of elements of the form $$\sum^n_i f_i c^{i-1}$$
    - $n$ is the degree of the minimum polynomial of $c$ over $F$
    - if $c$ is the root of $x^2+1 \in R(x)$ then
      $c+1 \notin R$ but $c^2 + 1 \in R$ so n = 2.
    - $n$ is called the *extension degree* over $F$: $$ [ F(c) : F ] = n $$
*** Multiple field extensions as vector space
    - An extension $F(c_1, c_2)$ can be seen as a vector space of elements of
      the form $$\sum^{n_1}_i \sum^{n_2}_j f_{i,j} c_1^{i-1}c_2^{j-1}$$
    - Adjoining several $c_k$ brings to a overall extension degree $n =\Pi_k n_k$.
*** Root field

Given a polynomial $a(x)$ with roots $c_1 \ldots c_n$, the field extension
$F(c_1 \ldots c_n)$ is its *root field*.

*** Field isomorphisms
:PROPERTIES:
:BEAMER_opt: fragile
:END:
There exists an isomorphism $h$ between field extensions over roots $a,b$ of the
same irreducible polynomial $p(x) \in F(x)$:

#+BEGIN_EXPORT latex
\begin{tikzcd}
F \arrow[r, hook] \arrow[rd, hook] & F(a) \arrow[d] \\
 & F(b) \arrow[u, "h"]
\end{tikzcd}
#+END_EXPORT

- If $h$ does not remap values in $F$ but only the roots we say that /$h$ fixes $F$/.
- It can be shown that $F(a)$ and $F(b)$ must be the same field extension $K$
  thus there is a single root field for every irreducible polynomial --- if it
  contains $a$ it should contain also $b$.

*** Galois group

- A root field automorphism is an isomorphism over the same field which fixes $F$:
   $$h_{p(x)}: F(c) \rightarrow F(c)$$

- Each $h_{p(x)}$ permutes only the roots.

- The number of $h_{p(x)}$ is the degree $[F(c) : F]$

- They are permutations and they form a group (the *Galois* group) $$Gal(F(c) : F)$$
- not all permutations can be considered because only a few determine root field
  automorphisms.

*** Fixed field                                                     :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Given a group $G$ and a field $K$, the *fixed field* $K^G$ is the 
set of $k \in K$ that remain constant under the action (by multiplication of $G$), i.e., 
where the following commutes:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
K^G \arrow[d, "(\cdot g)"] \arrow[r, "i", hook] \arrow[rd, "i", hook] & K \arrow[d, "(\cdot g)"] \\
K^G \arrow[r, "i", hook]                                              & K                       
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

One interesting group studied later is the group $G=Aut(L/K)$ where $L/K$ is 
an extension $L$ of $K$.


*** Galois extension                                                :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

An extension $L/K$ is a *Galois extension* of field $K$, if the following hold:

- all $l\in L$ are a root of $K[x]$ (i.e., $L$ it is an algebraic extension)

- The following commutes (fixed field) and the inclusion morphism is invertible:

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  K^{Aut(L/K)} \arrow[d, "(\cdot g)"] \arrow[r, "i", hook] \arrow[rd, "i", hook] & K \arrow[d, "(\cdot g)"] \\
  K^{Aut(L/K)} \arrow[r, "i", hook]                                              & K                       
  \end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

*** Orbit category                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Given a group $G$, the *orbit category* $O_G$ is a subcategory of quotient groups of $G$
 where morphims are $G$ equivariant maps of the left $G$ action:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\bullet \arrow[d, "g"] & G/H \arrow[d, "(g \cdot )"] \arrow[r, "m"] & G/K \arrow[d, "(g \cdot)"] \\
\bullet                & G/H \arrow[r, "m"]                        & G/K                       
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Galois correspondence                                           :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
F \arrow[r, hook] & {F[p_1]} \arrow[r, hook] & {F[p_1,p_2]} \\
\{id\} \arrow[r, hook] & {Gal(F[p_1] : F)} \arrow[r, hook] & {Gal(F[p_1,p_2] : F)}
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- There is a one-to-one correspondence between the subgroups of $Gal(F(c):F)$
  and the intermediate fixed fields between $F$ and $F[c]$, a.k.a, *Galois
  correspondence* ($p_1$ and $p_2$ are roots of two different polynomials).

- The number of elements of $H$ is $[F:I]$.

*** Galois correspondence example
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- Consider $Q(i,a)$ where $a$ is the root of 2. 

- $Gal(Q(i,a) : Q) = \{ \epsilon=id, \alpha=(\sigma_i id_a), \beta=(id_i \sigma_a), \gamma=(\sigma_i
  \sigma_a) \}$ using transpositions to represent permutations.

- Then we have the following Galois correspondence:

  #+BEGIN_EXPORT latex
  \tiny
  \begin{tikzcd}
  & {\{\epsilon,\alpha,\beta,\gamma\}} &  &  & {Q(i,a)} &  \\
  {\{\epsilon,\alpha\}} \arrow[ru] & {\{\epsilon,\beta\}} \arrow[u] & {\{\epsilon,\gamma\}} \arrow[lu] & Q(a) \arrow[ru] & Q(i) \arrow[u] & Q(ia) \arrow[lu] \\
  & \{\epsilon\} \arrow[lu] \arrow[u] \arrow[ru] &  &  & Q \arrow[lu] \arrow[u] \arrow[u] \arrow[ru] & 
  \end{tikzcd}
  #+END_EXPORT

*** Normal subgroup of a Galois group.
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{A = F[p_1, p_2]}          & F^A = Gal(A:F) \arrow[d, "h"]  & B^A = Ker(h) \arrow[l, hook] \\
{B=F[p_1]} \arrow[u, hook] & F^B \arrow[u, hook, bend left] &                             
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- Given a field $F$, its field extensions $B=F[p_1], A=F[p_1,p_2]$ might be ordered according to
  inclusion. Their Galois group $F^A$ and $F^B$ are automatically endowed with a homomorphism
  $h$ corresponding to a restriction of any $f \in F^A$ into $F^B$.

- This homomorphism has a kernel the group $B^A$, so $F^B = F^A/B^A$

*** Finite Field - order 
- The number of elements of a finite field is called its order.

- A field of order $q$ exists only if $q = p^k$ where $p$ is prime.

- A *prime field* is such $q=p$ for $p$ prime.

- In a field of order $p^k$, adding $p$ copies of any element always gives 0.

*** Finite Field - primitive element 

In a finite field of order $q$, the polynomial $X^q - X$ has all $q$ elements of the
finite field as roots (when $q$ is prime this is the fermat little theorem).

The non-zero elements of a finite field form a
multiplicative group. This group is cyclic, so all non-zero elements can be
expressed as powers of a single element called a primitive element of the field.

*** Finite Field - construction
- $GF(p^n)$ contains a subfield isomorphic to $GF(p^m)$ if and only if
  $m$ is a divisor of $n$;
- $GF(p^n)$ can be constructed by extending $GF(p)$, i.e., by
  choosing and irreducible polynomial $P$ in $GF(p)[X]$ of degree $n$
  and by computing the quotient ring $GF(p)[X]/\ang{P}$ where $\ang{P}$ is 
  the ideal generated by $P$.
- The elements of GF(q) are the polynomials over GF(p) whose degree is strictly
  less than n. 
- Except in the construction of GF(4), there are several possible choices for P,
  which produce isomorphic results.

*** Fundamental theorem of algebra                                                                 :noanki:
    - Every nonconstant polynomial with complex coefficients has a complex root.
    - If the coefficients are in $\mathbb{R}$ and $a+bi$ is a root, then also $a-bi$ is a root.

** Vector spaces
*** Vector space                                                                 :noanki:

    A pair $(V,K)$ where

    - $(K,(+,0),(\cdot,1))$ is a field
    - $(V,+,e)$ is an abelian group under addition

    Moreover, the following operation should be total (scalar multiplication)
    \[
    *: K \times V \rightarrow V
    \]

*** Direct sum                                                                 :noanki:

    The direct sum of two vector spaces is a linear combination (span) of their basis.

    $$V_1=span_k([0,1]), V_2=span_k([1,0]), V_1 \oplus V_2 = span_k([0,1],[1,0])$$

*** Normed vector spaces                                                                 :noanki:

    A *normed* vector space $V$ is endowed with a map $V \rightarrow R$.

*** Inner product spaces                                                                 :noanki:

    An *inner product* space $V$ is endowed with an operation $V \times V \rightarrow R$.

    Hermitian products are one of the possible operations

*** Conjugate vector spaces                                                                 :noanki:

    Given a vector space on complex numbers $V_C$ then also $\bar{V}_C$, where
     scalar multiplication is $\bar{z}*v$ for $z \in C$, is a vector space.


*** Dual Pair                                              :focus:
A /dual pair/ is a pair of vector spaces $X,Y$ and a bilinear map $\ang{}: X \times Y \mto K$.
*** Dual Space                                                      :focus:

    - Given a vector space $V$, one can define its dual space as the space of
      linear mappings over it, i.e., $V^* = \{f: V \rightarrow k \}$.

    - $K^V=V^*=span(f_1^*, \ldots, f_n^*)$ where $$f_i^*(\sum_j c_j e_j)=c_i$$
      and $V = span(e_1, \ldots, e_n)$.

    - $V$ and $K^V$ form a *dual pair* if we define the inner product with
      $\np{f}{x} = f(x)$ which is called the natural pairing.
   

*** Dual spaces (functor relation)                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{center}
\begin{tikzcd}
V \arrow[d, "f"]  & K^V \\
W & K^W \arrow[u, "Tf"]
\end{tikzcd}
\end{center}
#+END_EXPORT

- $V$ and $K^V$ form a dual pair if we define the inner product as: $\np{f}{x} = f(x)$
- $V$ and $K^V$ are also related by a functor relationship 
  $Tf[-] = (- \circ f)$
- The functor relationship can be expressed with the natural pairing notation as well:

  $$\np{Tf(w^*)}{v} = \np{w^*}{f(v)}$$

      
*** Affine space
    - A tuple $(A, V_k, (+): V_k \times A \rightarrow A)$ defines an /affine space/
      $A$ if $(+)$ complies with the group action properties.
    - Alternatively, it can be defined as $(A, V_k, (-): A \times A \rightarrow V_k)$ where
      $(-)$ complies with Weyl's axioms

*** Quotient space
    Given a vector space $V$ and a subspace $W$, the quotient space $V/W$ is the set of
    cosets $W_a = \{ a + w | w \in W \}$, i.e., the elements of $V$ distant $a$ from
    some $w \in W$. For $x,y,z \in W_a$:
    - $x-y \in W$ and $y-x \in W$
    - $x-x \in W$
    - $x-y \in W$ and $y-z \in W \rightarrow x-z \in W$

    $W_a$ is thus an equivalence class.

*** Free vector space

- Given a field $k$ and a set $S$, a free vector space $k[S]$ is generated by
  all the formal sums of the form: $$\sum_{s \in S} k_s *s$$.

- It is a vector space with a basis for each element of $S$.

*** Tensor product spaces

    Given two vector spaces $(V,V')$, I can define their tensor product $W =V
    \otimes V'$ by

    - creating monomials (concatenations) of their bases $e_i \otimes e'_j$ as
      a new basis for $W$

    - expressing the product $v \otimes v' = \sum_{c_{ij}}c_{ij} e_i \otimes e'_j$ such
      that the properties of a bilinear product hold.

*** Tensor product spaces (formal quotients of free vector spaces)

    Given two vector spaces $(V,V')$, I can define their tensor product $W =V
    \otimes V'$ by

    - Taking the free vector space $F = (V \times V') = span \{(u,v) | u \in U,
      v \in V\}$ (all elements become a basis!).

    - $V \otimes V' = F(V \times V') / I$ where $I$ is an ideal generated that
      makes $(a+b)\otimes c = a \otimes c + b \otimes c$ (and other constraints..).
      

*** Universal property of tensor products 
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:
#+BEGIN_EXPORT latex
\begin{tikzcd}
V \times W \arrow[r, "\phi"] \arrow[rd, "h"] & V \otimes W \arrow[d, "\tilde{h}"] \\
 & Z
\end{tikzcd}
#+END_EXPORT
    - Recall a bilinear map as a function that acts linearly and separately on each of its arguments.

    - All functions $\phi: V \times W \rightarrow V \otimes W$ that are
      bi-linear are isomorphic, so $\phi$ is called the universal bilinear map.

    - Any other bi-linear map $h: V \times W \rightarrow Z$ can be written as $h
      = \tilde{h} \circ \phi$ where $\tilde{h}$ is unique.

    - The tensor product is *associative* $(A \otimes B) \otimes C = A \otimes (B \otimes C)$


*** Exact sequence 

    In the context of group theory, a sequence of morphisms $G_0 \rightarrow^{f_0} G_1 \rightarrow^{f_1} ... G_n$ is 
    exact if the image of each moprhism is the kernel of the next.

    - The sequence 0 -> A -> B is exact only if the map from A to B is a monomorphism
    - The sequence B -> C -> 0 is exact only if the map from B to C is an epimorphism
    - The sequence 0 -> A -> B -> C -> 0 is called exact if A -> B is mono and B -> C is epi
    
*** Metric space                                                    :focus:

A metric space is a vector space possessing an inner product $\np{v}{w}$ that
allows length and angle to be measured. The inner product

- is conjugate symmetric: $\np{x}{y} = \overline{\np{y}{x}}$
- is conjugate linear $\langle x,ay_{1}+by_{2}\rangle ={\bar {a}}\langle x,y_{1}\rangle +{\bar {b}}\langle x,y_{2}\rangle$
- is positive definite $\np{x}{x} > 0 \iff x \neq 0$

The length (or norm) of $x$ is defined as $|x|=\sqrt{\np{x}{x}}$. The distance
$d(x,y)$ is the norm of the difference, i.e., $|x-y|$.

*** Hilbert space                                                   :focus:

A Hilbert space is a metric space which is also *complete*, i.e., every sequence
of vectors $u_k$ is such that $$\sum_k^{\infty}|u_k|<\infty$$

Concerning completeness, note, for example, that the set of rational numbers is not
complete, because e.g. ${\sqrt {2}}$ is "missing" from it, even though one can
construct a Cauchy sequence of rational numbers that converges to it.


*** Group presentation
- It is a way of specifying a group $G$. It is a set of generators $S$ and
  relations $R$ among generators and it is indicated with $\ang{S | R}$. 
- Relators $R$ are combinations of words in $S$ that are equal to the identity
  (e.g., $x=y \implies y^{-1}x \in R$).
- Formally to $$G=\ang{S|R}=F_S/\ang{R^{F_S}}$$ where $\ang{R^{F_S}}$ is the 
  conjugate closure of $R$.
- Examples:
  - $\ang{ \{a\}, \{a ^n=1\}}$ is the cyclic group
  - $\ang{r,f | r^8=f^2=(rf)^2 = 1}$ the dihedral group, i.e., the group of 
    symmetries of a polygon with 8 sides.


** Algebras and co-algebras
*** $k$ algebra (with tensor products)
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
K \otimes A \arrow[r, "u \otimes 1"] \arrow[rd] & A \otimes A \arrow[d, "\mu"] & A \otimes K \arrow[l, "1 \otimes u"'] \arrow[ld, "\cong"] \\
 & A \arrow[lu, "\cong"] \arrow[ru] & 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

It is a triple $(A,\mu,u)$, where $A$ is a vector space and with linear maps
$\mu: A \otimes A \rightarrow A$ and $u: K \rightarrow A$ such that the
following hold:

  - $m(a \otimes m(b \otimes c)) = m(m(a \otimes b) \otimes c)$
  - $\mu(u(1) \otimes x) = \mu(x \otimes u(1)) = x, \forall x$ (algebra is unitary)

*** $k$ algebra (as a ring)                                                                 :noanki:

    A tensor product $m: A \otimes A \rightarrow A$ makes $A$ a *ring* with
    a *bilinear* multiplication $\cdot: A \times A \rightarrow A$, i.e. $$ a \cdot b = m(a
    \otimes b)$$ Viceversa, we can create an $m$ from a ring $A$, because
    multiplication is a bilinear map.

*** Direct sum of abelian groups 

Given two abelian groups $A, B$, their direct sum $A \oplus B$ is the set of
pairs $(a,b)$ where the product is defined as $$(a_1, b_1) + (a_2, b_2) =
(a_1 + a_2, b_1 + b_2)$$

*** S-Graded object
- Given a set $S$ and a category $C$, a graded object is a functor $S
  \rightarrow C$, where the set $S$ is treated as a discrete category. 
  It can be seen as a family of objects $\{ C_{s\in S} \}$
- These families form a category $C^G$ where natural transformations between $X,
  Y: S \rightarrow C$ are morphisms.
- If $S$ is a monoid then $C^G$ can be equipped with a monoidal tensor product 
  $$(X \otimes Y)_s = \coprod_{u+v = s} (X_u \times Y_v)$$

*** Graded vector space

It is a vector space whose underlying abelian group can be seen as a direct sum
of other abelian groups (each one making up its own vector space)

$$V = \bigoplus_{n \in \mathbb{N}} V_n$$

where each $V_n$ is a vector space. For a given $n$ the
elements of $V_n$ are then called homogeneous elements of
degree $n$.

*** Graded ring

A graded ring is a ring that is a direct sum of abelian groups $R_i$ such that
$R_i R_j \subseteq R_{i+j}$, i.e., the product takes $R_{g} \times R_{g'} \rightarrow
R_{g g'}$

*** Graded module

A module $M$ is graded over a graded ring $R$ if 

- $M=\bigoplus M_i$ and
- $R_iM_j \subseteq M_{i+j}$

Examples: 

- A graded vector space is a graded module where $R$ has trivial grading.
- A graded ring is a graded module over itself.

*** Graded algebra

- A $k$ algebra $A$ is graded a graded module (over the ring $k$) where $\mu: A
  \otimes A \to A$ preserves the degree.

- It has a vector space decomposition: $$A = A_0 \oplus A_1 \oplus A_2 \cdots$$

- $A_i$ has homogeneous elements of degree $i$ such that $a_i \otimes a_j \in
  A_{i+j}$

*** Hilbert series of the dimensions of a graded $k$ algebra.      :noanki:

    The following formal series $$\textrm{Hilb}(A,q) = \sum_{d} \textrm{dim}(A_d)q^d$$ is 
    a formal series representing the dimensions of a graded algebra.

*** Example $k$ algebra: polynomials
- Polynomials $\KK[x]$ form a vector space with basis vectors $1, x, x^2,
  \ldots$ that can be equipped with a tensor product and a multiplication $$\mu:
  \KK[x] \otimes \KK[x] \rightarrow \KK[x]$$ that works as polynomial
  multiplication (e.g., $\mu(x^2 \otimes 3x) = 3x^3$) with $u(1) = 1$

- for $\KK[x] = \bigoplus_d (\KK[x^d])$ we have $$ \textrm{Hilb}(\KK,q)=\sum_d
  q^d$$

*** Example $k$ algebra: polynomials in more than one variable

    - for $B[x_1 ... x_n] = \bigoplus_d B_d$ where $$B_d=\KK[x_1^{a_1} ...
      x_n^{a_n}, a_1 + ... + a_n = d]$$ we have $$\textrm{Hilb}(B,q)=\sum_d
      {n+d-1 \choose d}q^d=(1-q)^{-n}$$

    # RESTART FROM HERE: https://www.youtube.com/watch?v=Extra4r0Y

*** Example $k$ algebra: group Algebra

    - A group algebra $\KK[G]$ for a group $G$ and a field $\KK$ is a vector space
      where every vector has the form $$z_1g_1 + z_2g_2 + \ldots$$

    - Multiplication defined on the basis elements is the group product
      $$\mu(g_i \otimes g_j) = g_ig_j$$ while $u(1)=e$

*** Tensor product of algebras
:PROPERTIES:
:BEAMER_opt: fragile
:END:
If $A$ and $B$ are $k$ algebras, so is $A \otimes B$ with $$\mu_{A \otimes B}(a_1 \otimes
b_1 \otimes a_2 \otimes b_2) = \mu_A(a_1 \otimes a_2)\otimes\mu_B(b_1 \otimes b_2)$$ 

in other words: 

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A \otimes B \otimes A \otimes B \arrow[rr, "id \otimes \tau \otimes id"] \arrow[rrrr, "\mu_{A \otimes B}", bend left] &  & A \otimes A \otimes B \otimes B \arrow[rr, "m_A \otimes m_B"] &  & A \otimes B
\end{tikzcd}
#+END_EXPORT
#+END_CENTER



*** Tensor algebra
 - A tensor algebra is a graded algebra $$T[V] = \bigoplus_d V^{\otimes d}$$
   where $V^{\otimes d}$ is $V$ tensored with it self $d$ times (itself an
   algebra). Multiplication $T(V) \otimes T(V) \rightarrow T(V)$ is
   juxtaposition extended linearly. 

 - It is is also called the *free algebra on the vector space V*, and is functorial. 

 - It is also a bi-algebra with $\Delta(v) = v \otimes 1 + 1 \otimes v$

*** Symmetric algebra
    - A symmetric algebra is a quotient algebra: $$SV = TV/(v\otimes w - w
      \otimes v)$$ The ideal is homogeneous so the resulting quotient is graded.
    - In other words, $v\otimes w = w \otimes v$.

*** Exterior algebra 
    An exterior algebra is a quotient algebra: $$\Lambda V = TV/(v\otimes v)$$
    The ideal is homogeneous so the resulting quotient is graded.
*** $k$ -Coalgebra 
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

It is a triple $(C, \Delta, \epsilon)$ where $C$ is a vector space,
$\Delta: C \rightarrow C \otimes C$, and $\epsilon: C \rightarrow k$
such that coassociativiy diagrams for $\Delta$ commute (same diagrams as
$k$ -algebra but reversed):

#+BEGIN_EXPORT latex
\begin{center}
\begin{tikzcd}
C \arrow[r, "\Delta"] \arrow[d, "\Delta"] & C \otimes C \arrow[d, "id \otimes \Delta"] \\
C \otimes C \arrow[r, "\Delta \otimes id"] & C \otimes C \otimes C
\end{tikzcd}

\begin{tikzcd}
 & C \arrow[d, "\Delta"] \arrow[ld] \arrow[rd] &  \\
\mathbb{F} \otimes C & C \otimes C \arrow[l, "\epsilon \otimes id"] \arrow[r, "id \otimes \epsilon"] & C \otimes \mathbb{F}
\end{tikzcd}
\end{center}
#+END_EXPORT

*** Example algebra: algebra $A = C*$ derived from an incidence co algebra $C = int(P)$ where $P$ is a 
poset

- Given an incidence co-algebra $C$, one can define its *incidence algebra* as the
  space $C^* = \{ f: C \rightarrow k \}$, where multiplication $m$ is $\Delta^*
  \circ \rho$ so:

  #+BEGIN_EXPORT latex
  \begin{equation}
  \begin{split}
  m(\phi \otimes \psi)([x,y]) & = \np{\Delta^* \circ \rho (\phi \otimes \psi)}{[x,y]} \\
  & = \np{\rho(\phi \otimes \psi)}{\Delta([x,y])} \\
  & = \sum_{z \in [x,y]}\phi([x,z])\psi([z,y]) 
  \end{split}
  \end{equation}
  #+END_EXPORT

- The unit $u: k \rightarrow C^*$ is the linear extension of $$u(1) = [x,y] \mapsto x == y $$

*** Deriving a $k$ algebra from a $k$ co-algebra      
:PROPERTIES:
:BEAMER_opt: fragile
:END:
- Given a co-algebra $C$, $C^*$ is an algebra (over $k^{\star}$). In fact, I can
  build $u,m$ and $\rho$ such that the following diagrams commute:

  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  K \arrow[r, "u"] \arrow[rd, "\phi"] & C^* & C^* \otimes C^* \arrow[r, "m"] \arrow[rd, "\rho", hook] & C^* \\
  & K^* \arrow[u, "\epsilon^*"] &  & (C \otimes C)^* \arrow[u, "\Delta^*"]
  \end{tikzcd}
  #+END_EXPORT

- $C^*$ is the convolution algebra as it uses convolution to multiply functions
  living in $C^*$. 

- Note: $(\rho(c^* \otimes d^*), c \otimes d) = (c^*, c)(d^*, d)$ is a
  homomorphism and an injection.

- $\phi$ is a linear function that maps $K$ to functions on $K$. 

*** Example $k$ coalgebra: Polynomial co-algebra
- One can build a co-algebra on polynomials them selves, when each basis of the
  tensor space built over $\KK[x]$ can be decomposed through comultiplication
  as: $$\Delta(x^n) = \sum_i x^i \otimes x^{n-i}$$
- and co-unit $\epsilon: \KK[x] \rightarrow \KK$ as $$\epsilon = x^n \mapsto (n==0)$$
 
*** Example $k$ coalgebra: Incidence coalgebra $C = int(P)$
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Let $int(P)$ be the free vector space of intervals. Define a
co-multiplication: $$\Delta([x,y])=\sum_{z \in [x,y]} [x,z] \otimes [z,y], ~~
\epsilon([x,y]) = (x=y)$$

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
 & g &  \\
e \arrow[ru] & b \arrow[u] & f \arrow[lu] \\
c \arrow[u] \arrow[ru] & d \arrow[u] \arrow[ru] &  \\
a \arrow[ru] \arrow[u] &  & 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

we have $\Delta([a,g]) = [a,b] \otimes [b,g] + [a,d] \otimes [d,g] + \ldots$

*** Example $k$ coalgebra: Coalgebra of set 
Take a set $S$, we have that the formal sums of the set's elements $C = \KK[S]$
(or $C=span(S)$) is a co-algebra with $\Delta_C(s)= s \otimes s \forall s \in S$ and
$\epsilon(s) = 1 \forall s \in S$.

*** Example $k$ coalgebra: Set of subsets ordered 

Given a set $S$, one can define the a poset over it, ordered by inclusion: $$2^S
= \{ T \subset S \}$$ Given this poset, one can build an incidence co-algebra $C=int(2^S)$

*** Example $k$ coalgebra: group co-algebra

    - A group coalgebra $\KK[G]$ for a group $G$ and a field $\KK$ is a vector
      space where every vector has the form $$z_1g_1 + z_2g_2 + \ldots$$ and where 
      $$\Delta(g) = g \otimes g, \epsilon(g)=1 \forall g$$



*** Sub-algebra 
Given: 

- $B$ is an algebra
- $A \subseteq B$ (subspace) 

then:

- $A$ is a *sub-algebra* if $m(A \otimes A) \subseteq A$ and $1_B \in A$
- $A$ is an ideal if $m(A \otimes B) \subseteq A$ (and viceversa, if you want a
  *two sided ideal*).

*** Sub-coalgebra 

Given:

- D co-algebra 
- $C \subseteq D$ (subspace)

then 

- $C$ is a sub-coalgebra if $\Delta(C) \subseteq C \otimes C$
- $C$ is a co-ideal if $\Delta(C) \subseteq C \otimes D + D \otimes C$

*** Duality of homomorphisms                                       :noanki:

Proposition: given $f: C \rightarrow D$ a co-algebra homomorphism, $f^*: D^*
\rightarrow C^*$ is an algebra homomorphism.

One should prove that $f^*$ is multiplicative: $$f^*(d^* e^*) = f^*(d^*)f^*(e^*)$$

because: $$\np{\fs(\ds\es)}{c} = \np{\ds\es}{f(c)}$$

*CONTUNUE FROM HERE, NOT FINISHED*

*** Mobius function                                                                 :noanki:

- Given an incidence algebra $\phi$, one can ask whether there exists a way to
  build the multiplicative inverse of each function in $C^*$, and in particular of
  the inverse of $\zeta([x,y])=1$ which we call $\mu$.

- This is in fact the mobius function which we define recursively:
  $$\mu([x,y])=-\sum_{z\in[x,y]}\mu([x,z])$$

*** Sweedler notation for co-algebras

- Assume you want to write a formula for $\Delta: C \rightarrow C \otimes C$; this 
  actually corresponds to a linear combination of tensors:
  $$\Delta(c) = \sum_i \lambda_i (c_{1,i} \otimes c_{2,i}) \cong \sum_i (c_{1,i} \otimes c_{2,i})$$
  $$ = \sum_{(c)} (c_{(1)} \otimes c_{(2)})$$

  where $\lambda_i$ is absorbed and subscript notation is removed.
- Extension:

  \begin{equation}
  \begin{split}
  \Delta_2 (c) = (\Delta \otimes id) \circ \Delta & = \sum_{(c)} c_{(1)} \otimes c_{(2)} \otimes c_{(3)} [: C  \rightarrow C \otimes C \otimes C ]\\ 
  \Delta_{n-1}(c) & = \sum_{(c)} c_{(1)} \otimes \ldots \otimes c_{(n)} [: C \rightarrow \otimes^n C ] \\
  \end{split}  
  \end{equation}

*** Co-algebra laws in sweedler notation 
- Co-associativity law: $$\sum_c \Delta(c_1)\otimes c_2 = \sum_c c_1\otimes \Delta(c_2) =: \Delta_2(c)$$
- Co-unit law: $$\sum_c \epsilon(c_1)\otimes c_2 = \sum_c c_1 \otimes \epsilon(c_2) = c$$
- If $f = \phi \circ \Delta_i$ then $$\sum_c \phi(c_1 \otimes c_2 \ldots) = \sum_c f(c_1) \otimes c_2 \otimes \ldots$$

*** $k$ algebras homomorphisms
:PROPERTIES:
:BEAMER_opt: fragile
:END:
 #+BEGIN_CENTER
 #+BEGIN_EXPORT latex
 \begin{tikzcd}
A \otimes A \arrow[r, "f \otimes f"] \arrow[d, "m_A"] & B \otimes B \arrow[d, "m_B"] \\
A \arrow[r, "f"] & B \\
 & K \arrow[lu, "u_A"] \arrow[u, "u_B"]
\end{tikzcd}
 #+END_EXPORT
 #+END_CENTER

If $f$ is linear and it respects the above commutative diagrams then it is a homomorphism.

*** $k$ co-algebra homomorphisms
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
C\otimes C &  & D \otimes D \arrow[ll, "f \otimes f"] \\
C \arrow[u, "\Delta_C"] \arrow[rrd, "\epsilon_C"] &  & D \arrow[u, "\Delta_D"] \arrow[ll, "f"] \arrow[d, "\epsilon_D"] \\
 &  & K
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

In Sweedler notation: $$\sum_{(d)} f(d_{(1)}) \otimes f(d_{(2)}) = \sum_{f(d)} f(d)_{(1)} \otimes f(d)_{(2)}$$

*** Co-algebra homomorphism $kS \rightarrow int(2^S)$ where $S$ is a set
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- Given a generator of $kS$ (i.e., an element $s \in S$) it maps to an interval
  in $int(2^S)$

- One can try with $f: s \mapsto [ \{s\}, \{s\}]$ and in fact it respects
  co-associativity and co-unit.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{[\{s\},\{s\}] \otimes [\{s\},\{s\}]} &  & s \otimes s \arrow[ll, "f \otimes f"] \\
{[\{s\},\{s\}]} \arrow[u, "\Delta_{Int(2^S)}"] &  & s \arrow[u, "\Delta_{KS}"] \arrow[ll, "f"]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Group Algebra as formal sum                                                                 :noanki:

    - A group algebra $\KK[G]$ for a group $G$ and a field $\KK$ is a vector space
      that is the direct sum of copies of $\KK$ indexed by $G$.

    - In practice, the basis $e_g$ is a vector that has a dimension $|G|$ and
      whose $g-th$ component is 1.

    - Each element of the algebra is thus a formal linear combination of the
      elements of $G$ with coefficients in $\KK$, i.e., $$f = \sum_{g\in G}a_{g,f}
      e_g$$ where $e_g$ are basis in $\KK[G]$.

*** Group Algebra as function space

    Given a group $G$ and a field $K$, we can build an algebra $K[G]$ where

    - vectors are functions $f: G \rightarrow K$ for $K$ either a ring or
      field.
    - $(f_1 + f_2) = g \mapsto f_1(g) + f_2(g)$
    - $(\alpha f) = g \mapsto \alpha f(g)$
    - $(f_1 \times f_2) = g \mapsto \sum_{u \in G}f_1(u)f_2(u^{-1}g)$

*** $k$ Bialgebra
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A \otimes A \arrow[d, "\mu"] \arrow[r, "\Delta \otimes \Delta"] & A \otimes A
\otimes A \otimes A \arrow[d, "\mu_{2} "] \\
A \arrow[r, "\Delta"] & A \otimes A
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- A bialgebra is both an algebra and a coalgebra where $\Delta$ and $\epsilon$
  are algebra ($A \rightarrow A \otimes A$) morphisms. Equationally:

  $$\Delta(a_1 \cdot_{\mu} a_2) = \Delta(a_1) \cdot_{\mu_2} \Delta(a_2)$$

  where $a \cdot_{\mu} b = \mu(a \otimes b)$ and $\mu_2$ is the multiplication
  over $A \otimes A$ implied by $A$, i.e. $$\mu_2 = (\mu \otimes \mu)(id \otimes
  \tau \otimes id)$$


*** $k$ Bialgebra example: group bialgebra

The group algebra $\KK[G]$ where $$\mu(g_i \otimes g_j) = g_ig_j, ~~ u(1)=e_G$$

is also a co-algebra with $$\Delta(g) = g \otimes g, \epsilon(g)=1 \forall g$$

It can be shown that 
 #+BEGIN_EXPORT latex
 \begin{align*}
  \Delta(g_i \cdot_{\mu} g_j) & = \sum (g_ig_j \otimes g_ig_j) \\
                   & = \sum \mu_2(g_i \otimes g_i \otimes g_j \otimes g_j) = \Delta(g_i) \cdot_{\mu_2} \Delta(g_j)
 \end{align*}
 #+END_EXPORT

*** $k$ Bialgebra - algebra $A^C$                                   :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given $A$ and $C$ respectively an algebra and a co-algebra, $A^C$ is the
homology group of $A$ and $C$ with product $$\star: A^C \times A^C \rightarrow
A^C$$ such that $$f \star h = \mu \circ (f \otimes h) \circ \Delta$$ and unit $T
= u \circ \epsilon$. If there is an $S$ for which $Id \star S = T$ then $S$ is
called an antipode.


*** $k$ Bialgebra - antipode (Hopf algebra)                         :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

An Hopf algebra is a bi-algebra with an antipode.
An *antipode* $S$ is the morphism $A \rightarrow A$ for which 
the following commutes:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A \otimes A \arrow[d, "id \otimes S"] & A \arrow[d, "T = u \circ \epsilon"] \arrow[l, "\Delta"] \arrow[r, "\Delta"] & A \otimes A \arrow[d, "S \otimes id"] \\
A \otimes A \arrow[r, "\mu"]          & A                                                                       & A \otimes A \arrow[l, "\mu"]         
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

In Sweedler notation, $$T(a) = u(\epsilon(a)) = \sum a_1S(a_2) = \sum S(a_1)a_2$$

*** $k$ Bialgebra - antipode as the inverse of an identity          :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given $A$ a bi-algebra with antipode $S$, $S$ is the inverse of $id_A$ in the 
$(A^A, \star, u \circ \epsilon)$ algebra.

*** $k$ Bialgebra - antipode for a group algebra                    :focus:

The antipode $S$ for a group algebra is such that $$\mu \circ (Id
\otimes S) (g \otimes g) = T(g)$$ i.e., since $T(g) = e \forall g$, $$S(g) = g^{-1}$$
*** Opposite algebras and co-algebras

- Given an algebra $A$, the opposite co-algebra $\bar{A}$ is the same as A but with multiplication inverted.

- Given a co-algebra $C$, the opposite co-algebra $\widetilde{C}$ is the same as
  C but with co-multiplication such that: $$\Delta_{\widetilde{C}} := \tau \circ \Delta_C$$

- Given a bi-algebra $B$, $\widetilde{\bar{B}}$ is a bi-algebra.

*** Antipode as a morphism of Hopf algebras

Given an Hopf algebra $H$, the antipode $S$ is a morphism $H \rightarrow
\widetilde{\bar{H}}$ (the latter is the /opcop/ algebra). This means that it is
both an algebra morphism: $$ S(x \otimes_1 y)=S(x) \otimes_2 S(y), S \circ u_1 =
u_2$$ and a co-algebra morphism:
$$(S \otimes S)\circ\Delta_1 = \Delta_2 \circ S, \epsilon_2 \circ f = \epsilon_1$$




** Modules
*** R-Module

    Generalization of vector space. A pair $(V,K)$ where

    - $(K,(+ ,0),(\cdot,1))$ is a *ring*
    - $(V,+,e)$ is an abelian group under addition

    Moreover, the following operation should be total (scalar multiplication)
    \[
    *: K \times V \rightarrow V
    \]

*** Modules over division rings

    - Much of the linear algebra results can be applied to modules over division
      rings as the latter are almost fields.

*** Simple module

It is a module that does not have non-zero proper submodules

*** Semisimple module
A module is semisimple if it is the direct sum of simple (irreducible)
submodules

*** Projector                                                                 :noanki:
    - A *projector* is a linear operator $P: X \rightarrow X$ for which $P^2=P$.

    - It is characterized by the exact sequence: $$(1-P)X \rightarrow X
      \rightarrow_P X$$ i.e., $(1-P)X$ is its kernel.

    - $P$ endows $X$ with a direct sum composition $$X \simeq X_1 \oplus X_2 =
      PX \oplus (I-P)X$$

*** Projector image                                                                 :noanki:
      The image of a projector $P$ is an *invariant* under $P$: $$ P(PX)=(PX) \sim Pw=w$$

*** Projector kernel                                                                 :noanki:
      Given a projector $P$, $X_2 = (1-P)X$ is the kernel of $P$ by definition: $$PX_2 = P(1-P)X = (P-P^2)X = 0$$

*** Representation of algebras
Given an algebra $A_k$ and a vector space $V_k$ ($k$ is a field), a
representation of $A$ is a homomorphism: $$T: A \rightarrow Hom_k(V, V)$$

which satisfies: 

- $T(a_1 + a_2) = T(a_1) + T(a_2)$
- $T(a_1a_2)=T(a_1)T(a_2)$
- $T(\alpha a)=\alpha T(a)$

*** A-Module 
:PROPERTIES:
:BEAMER_opt: fragile
:END:

An $A$ module is a vector space $V$ where in place of a ring or a field, we use
use an algebra. The multiplication $\lambda: A \times V \rightarrow V$ is just
the uncurried representation of a ring homomorphism $A$ $$\rho_A: A \rightarrow
(V \rightarrow V)$$
The operation $\lambda$ is such that the following commutes:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A \otimes A \otimes V \arrow[d, "m \otimes id"] \arrow[r, "id \otimes \lambda"] & A \otimes V \arrow[d, "\lambda"] & k \otimes V \arrow[ld, "s"] \arrow[l, "u \otimes id"] \\
A \otimes V \arrow[r, "\lambda"]                                                & V                                &                                                      
\end{tikzcd}
#+END_EXPORT
#+END_CENTER




*** Z-Module

A module is a ring homomorphism into the endomorphism ring of an abelian group. Since $Z$ is the 
initial object in the category of rings, there is a single $Z$-module for each abelian group.

* Category theory 
** Category basics
*** Category                                                                 :noanki:

A category is a triple $\mathcal{C}(O, M, \bullet)$ that abides these laws:

- *identity*: $\forall o \in O, \exists id_o \in M$

- *composition*: '$\bullet$' composes morphisms in $M$ that share source and target :

  1. $\bullet(A \rightarrow B, B \rightarrow C) = A \rightarrow C$

  2. $(f \bullet g) \bullet h == f \bullet (h \bullet g)$

  3. $id_x \bullet f = f \bullet id_y$

*** Section
    - A section $s$ for a morphism $f$ is such that $$f \circ s = Id$$
      
    - Every section is a mono-morphism.

    - A section is always paired with a retraction: $r \circ s = Id$. $r \circ s$
      form always a pair $e \circ m$ where $e$ is epi and $m$ is mono.

*** Retraction
    - A retraction $r$ for a morphism $f$ is such that $$r \circ f = Id$$
    
    - Every retraction is an epi-morphism

    - A retraction is always paired with a section: $r \circ s = Id$. $r \circ s$
      form always a pair $e \circ m$ where $e$ is epi and $m$ is mono.

** Monoid (Category)

*** Monoid as a category                                                                 :noanki:
    - A monoid $\mathcal{M}(M, id_0, \star)$ is just a category $\mathcal{C}(O, M, \star)$ where O = $\{ o_1 \}$ and $id_0 = id_{o1}$.

    - The elements $M$ of a monoid are the morphisms $M$ of the corresponding
      category. As such, *associativity* holds.

*** Free Monoid                                                                 :noanki:
:PROPERTIES:
:placement: 18,0
:END:

- A free monoid of M is just a monoid $\mathcal{M}(List[G], [], ++)$

- It has a free generator set G and all its elements are uniquely determined by
  a fold of elements in $G$.

*** Action                                                                 :noanki:

An action of a $\mathcal{M}(M, id_0, \star)$ over a set $S$ of states is a
function  \[ \alpha: M \times S \rightarrow S \]. The following properties should be satisfied:

- identity: $\alpha(id_0, s) = s$

- compatibility: $\alpha(f \star g, s) = \alpha(f, \alpha(g, s))$

** Preorder, partial and linear order (Category)

*** Preorder as a category

A *preorder* is a category $\mathcal{C}(O, M, \bullet)$, where there is at most one
morphism between objects. It has the following properties:

- *reflexivity*: from identity morphisms

- *transitivity*: from composition of morphisms

*** Partial order as a category

A *partial order* (*poset*) is a preorder where, if there are arrows, these cannot
form loops (except for identity arrows).

- *reflexivity*: from identity morphisms

- *transitivity*: from composition of morphisms

- *antisimmetry*: $x \rightarrow y \rightarrow x \Rightarrow x = y$

*** Poset interval
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given a poset $P$, one can define an interval as the *subposet* $I_{x,y}=\{ i: x \leq i \leq y \},
x,y,i \in P$. For example, here:

#+BEGIN_EXPORT latex
\begin{tikzcd}
 & g &  \\
e \arrow[ru] & b \arrow[u] & f \arrow[lu] \\
c \arrow[u] \arrow[ru,red] & d \arrow[u,red] \arrow[ru] &  \\
a \arrow[ru,red] \arrow[u,red] &  & 
\end{tikzcd}
#+END_EXPORT

Red represents $I_{a,b}$ 

*** Linear order as a category

- A Linear order is a partial order where there exists at least 1 arrow between elements:

  \[x \rightarrow y \in M \Rightarrow y \rightarrow x \notin M\]

- Basically, either one or the other but all objects pairs have morphisms

*** Meet                                                                 :noanki:

A *meet*

- is the unique *product* of two objects in a poset

- it is regarded as the *minimum* of two objects

- in boolean algebra, it can be seen as the *and* operation

*** Join                                                                 :noanki:

A *join*

- is the unique *coproduct* of two objects in a poset

- it is regarded as the maximum of two objects

- in boolean algebra, it can be seen as the *or* operation

** Special categories
*** Categorical nomenclature (*small* and *large* cats)                                                                 :noanki:

    - A *class* is a collection of sets that share a property.

    - Large category $C$: Either $ob(C)$ or both $ob(C)$ and $hom(C)$ are proper
      classes (i.e., a class that is not a set).

    - Locally small category $C$: $hom(C)$ is a set (*Set* is just an example)

    - Small category $C$: $ob(C)$ and $hom(C)$ are sets

*** Groupoid                                                                 :noanki:

 A (small) *groupoid* is a (small) category in which all morphisms are
 *isomorphisms*. I.e., composition has a *two sided inverse*.

*** Big category                                                                 :noanki:

 A category of categories ($CAT$) that:

 - has functors as morphisms
 - excludes itself.

*** Product category                                                                 :noanki:

Given two categories $C$ and $D$, a product category $C \times D$ is such that

- Objects are all possible pairs of original objects

- Morphisms are all the corresponding morphisms

*** Monoidal and cartesian categories (diagram)
:PROPERTIES:
:BEAMER_opt: fragile
:END:
# edit here: https://tikzcd.yichuanshen.de/#eyJub2RlcyI6W3sicG9zaXRpb24iOlsyLDBdLCJ2YWx1ZSI6IlxcdGV4dGJme01vbm9pZGFsfSJ9LHsicG9zaXRpb24iOlszLDBdLCJ2YWx1ZSI6IihcXG90aW1lcywgMSwgXFxhbHBoYSwgXFxsYW1iZGEsIFxccmhvKSJ9LHsicG9zaXRpb24iOls1LDFdLCJ2YWx1ZSI6IlxcdGV4dGJme0JyYWlkZWR9In0seyJwb3NpdGlvbiI6WzUsMl0sInZhbHVlIjoiXFx0ZXh0YmZ7U3ltbWV0cmljfSJ9LHsicG9zaXRpb24iOls2LDFdLCJ2YWx1ZSI6IlxcZXhpc3RzIEJfe3h5fTogeCBcXG90aW1lcyB5IFxccmlnaHRhcnJvdyB5IFxcb3RpbWVzIHgifSx7InBvc2l0aW9uIjpbNiwyXSwidmFsdWUiOiJCX3t4eX0gXFxjaXJjIEJfe3l4fSA9IDFfe3ggXFxvdGltZXMgeX0ifSx7InBvc2l0aW9uIjpbMiwzXSwidmFsdWUiOiJcXHRleHRiZntDYXJ0LiBDbG9zZWR9In0seyJwb3NpdGlvbiI6WzIsMl0sInZhbHVlIjoiXFx0ZXh0YmZ7Q2FydGVzaWFufSJ9LHsicG9zaXRpb24iOlszLDJdLCJ2YWx1ZSI6IihcXG90aW1lcyA9IFxcdGltZXMpICsgXFx7IFxcRGVsdGEsIFxcZXBzaWxvblxcfSJ9LHsicG9zaXRpb24iOlszLDNdLCJ2YWx1ZSI6IkhvbV9DKGEgXFx0aW1lcyBiLGMpIFxcY29uZyBIb21fQyhhLGJeYykifSx7InBvc2l0aW9uIjpbMSwyXSwidmFsdWUiOiJcXHRleHRiZntDb0NhcnRlc2lhbn0ifSx7InBvc2l0aW9uIjpbMSwzXSwidmFsdWUiOiJcXHRleHRiZntCaUNhcnRlc2lhbn0ifSx7InBvc2l0aW9uIjpbMCwyXSwidmFsdWUiOiIoXFxvdGltZXMgPSArKSJ9XSwiZWRnZXMiOlt7ImZyb20iOjIsInRvIjowfSx7ImZyb20iOjMsInRvIjoyfSx7ImZyb20iOjcsInRvIjowfSx7ImZyb20iOjYsInRvIjo3fSx7ImZyb20iOjgsInRvIjozfSx7ImZyb20iOjExLCJ0byI6MTB9LHsiZnJvbSI6MTEsInRvIjo3fV19

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\tiny
\begin{tikzcd}
 & \textbf{Monoidal} & {(\otimes, 1, \alpha, \lambda, \rho)} &  \\
 &  & \textbf{Braided} \arrow[lu] & \exists B_{xy}: x \otimes y \rightarrow y \otimes x \\
{(\otimes = \times) + \{ \Delta, \epsilon\}} & \textbf{Cartesian} \arrow[uu] \arrow[r] & \textbf{Symmetric} \arrow[u] & B_{xy} \circ B_{yx} = 1_{x \otimes y} \\
{Hom_C(a \times b,c) \cong Hom_C(a,b^c)} & \textbf{Cart. Closed} \arrow[u] &  & 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


*** Monoidal category 
   - A category $C$ is *monoidal* if: 

     1. there is a tensor product $\otimes: C \times C \rightarrow C$ defined
        for all objects that respects associativity (through associators and unitors).

     2. there is a unit object for that product.

   - A category with finite products can always be made into a monoidal category
     by choosing a specific product to be the tensor product

*** Cartesian category
- It is a monoidal category where the tensor product is a normal product defined
  for all objects and the unit is the terminal object.

- In a cartesian category, we can "duplicate and delete information" through the
  duplication morphism $\Delta_X: X \rightarrow X \times X$ and the map into the
  terminal object $!_X: X \mto 1$

*** Closed category                                                 :focus:

- In a closed category there is also an object representing *all* the morphisms
  from $X$ to $Y$ denoted $Y^X$. In a closed category, we have: $$hom(X \otimes
  Y, Z) \cong hom(Y, Z^X)$$ The natural isomorphism is called *currying*.

- Visually, there is a one to one correspondence

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \includegraphics[width=4cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/key/page-2-crop.pdf}
  #+END_EXPORT
  #+END_CENTER



*** Closed category - name of a morphism                            :focus:

- The *name* of a morphism $f: X \mto Y$ is a morphism $[f]: I \mto Y^X$, i.e., an
  element of $Y^X$

- One can recover the original $f$ with the *evaluation* morphism $ev$: 
  $$ f = ev \circ (Id \otimes [f]) \circ r^{-1}$$ where $r^{-1}: X \mto X \otimes I$.

- The evaluation map is the uncurrying of the identity on $Y^X$

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \includegraphics[width=3cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/key/page-1-crop.pdf}
  #+END_EXPORT
  #+END_CENTER



*** Compact closed category - name of a morphism                    :focus:

- The *name* of a morphism $f: X \mto Y$ is a morphism $[f]: I \mto X' \otimes Y$
  (the latter in a CCC is the exponential object)

- In a CCC the evaluation is just $\epsilon_X \otimes Id$

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=3cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/key/page-3-crop.pdf}
#+END_EXPORT
#+END_CENTER

- A value of $X' \otimes Y$ encodes $f$ (gate teleportation).


*** Compact category                                                :focus:

A compact (or /autonomous/) category is such that every object $X$ has a dual $X'$: 

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/compactdual.pdf}
#+END_EXPORT
#+END_CENTER

and there are unit $i_X: I \cong X \otimes X'$ and co-unit $\epsilon_X: X
\otimes X' \cong I$ natural transformations that satisfy the zigzag equations:


#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/zigzag.pdf}
#+END_EXPORT
#+END_CENTER


*** Compact closed category                                         :focus:

- A compact category is automatically closed, i.e., the exponential object be
  defined as $$Y^X = X' \otimes Y$$ and it can be shown that it satisfies
  currying. The currying isomorphism assumes a particular form as the following
  two diagrams are equivalent:

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{figure}
  \subfigure{\includegraphics{/Users/zaccaria/development/github/org-institutional/anki-cards/images/cchom1.pdf}}
  \subfigure{\includegraphics{/Users/zaccaria/development/github/org-institutional/anki-cards/images/cchom2.pdf}}
  \end{figure}
  #+END_EXPORT
  #+END_CENTER 





*** Dagger category
A dagger category is a category $C$ which has a contravariant functor $\dag$ that is 
identity on objects and is such that $$\vdag{(\vdag{f})} = f$$ for all morphisms.
Any morphism $f$ in the category Hilb has a $\vdag{f}$ defined as: $$\ang{\vdag{f}w,v} = 
\ang{w,fv}$$. It is called the *Hilbert space adjoint*.
*** Cartesian closed category
It is a cartesian category that has exponentials.


*** Monoidal category of endofunctors 
    Endofunctors and natural transformations form a category. If there are
    additional natural transformations of the type $T\times T \rightarrow T$ then
    this category is a monoidal category. These monoids are called monad.

*** Category of objects under object $b$ (coslice category)
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Assume $b$ is an object of category $C$ and construct the category of objects
under $b$ called $(b \downarrow C)$ with objects all pairs $\np{f}{c}$ where $f$
is an arrow $f: b \rightarrow c$. Morphisms between these objects are those that
make the following diagram commute:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
 & \mathbf{b} \arrow[ld, "f", dotted] \arrow[rd, "f'", dotted] &  \\
c \arrow[rr, "h"] &  & c'
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


One might define also the category of /objects over $a$/ called $(C \downarrow a)$
by taking the opposite arrows.

*** Category of pointed sets $Set_{\star}$ (example of co-slice category)

In this category, 

- An object is a pointed set $(A \in Set,\nu_a)$ with a distinguished point $\nu_a \in A$.

- A morphism $f: A \rightarrow B$ is a morphism that is /point preserving/ if
  $f(\nu_a) = \nu_b$

- This category corresponds to $(\star \downarrow Set)$ where $\star$ is the
  singleton set, as arrows between $\star$ and any set corresponds to picking
  element $\nu_A$ in it.

*** Category of objects (functor)-under object $b$
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Given the functor $S: D \rightarrow C$, the category of objects /S-under/ $b$ ($b
\downarrow S$) is the set of all pairs $\np{f}{d}$ and morphisms $h$ that make 
the following diagram commute:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
 & b \arrow[ld, "f"] \arrow[rd, "f'"] &  \\
Sd \arrow[rr, "Sh"] &  & Sd'
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


*** Category of objects (functor)-under object $X$, example $Grp \rightarrow Set$
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
 & X \arrow[ld, "i_{GX}"] \arrow[rd, "i_{G'X}"] &  \\
\vert G \vert \arrow[rr, "Sh"] &  & \vert G'\vert
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- $S$ is the forgetful $Grp \rightarrow Set$, and $X$ is a set

- The category ($X \downarrow S$) has objects $\np{G}{i_{GX}}$
  where $i_{GX}$ maps $X$ into the underlying set of $G$ while morphisms
  $h$ are those that make the above diagram commute.

- The /free group/ on X ($F(X)$) is the initial object in this category


*** Product and permutation category (PROP)

- A PROP is a symmetric monoidal category with objects the natural numbers,
  the monoidal operator $\oplus$ is addition. 

- They are used to describe a given sort of algebraic structure. Every object is
  of the form $$x^{\otimes n} = x \otimes x \otimes \cdots \otimes x$$

*** Product and permutation category *FinSet*

- *FinSet* is a PROP where morphisms $f: m \mto n$ are functions from the set
  $\ubr{m} = \{1 \ldots m\}$ to the set $\ubr{n}=\{1 \ldots n\}$.

- The monoidal product of two morphism is obtained by pasting one above the
  other the two original morphism and the inputs and output set.

*** Product and permutation Bij

A PROP *Bij* has morphisms $f: m \mto n$ bijections $\ubr{m} \mto \ubr{n}$. Note
that for $m \neq n$ the homset is empty. The morphisms are just permutations.

*** Product and permutation $Rel_{Fin}$

Morphisms $m \mto n$ are relations $R \subseteq \ubr{m} \times \ubr{n}$. The
composition $R.S$ ($S \subseteq \ubr{n} \times \ubr{p}$) is the set of pairs
$(i,k) \in \ubr{m} \times \ubr{p}$ for which $$\exists j. (i,j) \in R \wedge (j,k) 
\in S$$

*** Symmetric monoidal theory (presentation for a PROP)                                                                 :noanki:

- A *symmetric monoidal theory* (or /presentation/) for any PROP $G$ is a pair
  $(\Sigma, E)$ where $\Sigma$ is the set of morphisms (generators) of type $n
  \rightarrow m$ other than $id$ and $\sigma$, 
  while $E$ is a set of equations over $\Sigma$.
- A $\Sigma$ term is any morphism that can be built by composing the generators. 

*** Freely generated PROP                                                                 :noanki:
Given a symmetric monoidal theory $(\Sigma, E)$, a *freely generated PROP* $G$ is
the set of expressions that one can construct with elements in $\Sigma$
quotiented over $E$ (and the axioms of PROP)

*** SMT for a monoid                                                                 :noanki:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- For a monoid $(M, m, 1)$, an SMT $(\Sigma, E)$ is composed of the following
  equations (white dot is multiplication).

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \includegraphics[width=10cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/monoid.png}
  #+END_EXPORT
  #+END_CENTER

- The freely generated PROP $\MM$ is isomorphic with FinSet, so we say that
  the theory of commutative monoids *presents* FinSet. 

*** SMT for a co-monoid                                                                 :noanki:

For a co-monoid, black dot is $\Delta$

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=10cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/comonoid.png}
#+END_EXPORT
#+END_CENTER

*** SMT for a bi-algebra                                                                 :noanki:

The operations of a co-monoid are monoid morphisms:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=10cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/bialgebras.png}
#+END_EXPORT
#+END_CENTER

- (A7) is $\epsilon(m(a \otimes b)) = \epsilon a \otimes \epsilon b$
- (A8) is $\Delta \circ m = (m \otimes m) \circ (id \otimes \tau \otimes id)
  \circ (\Delta \otimes \Delta )$

*** SMT for a special frobenius algebra                                                                 :noanki:

A Frobenius algebra is a second way (other than bi-algebra) to combine a monoid 
and a co-monoid:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=10cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/frobenius.png}
#+END_EXPORT
#+END_CENTER

- (F1 - pseudo-commutativity) $\Delta \circ m = (m \otimes id) \circ (id \otimes \Delta)$
- (F2 - factorization) says that co-multiplication factorises the original element
  
*** PROP sum                                                                 :noanki:
- Given two PROPs A and B, one can define their co-product $C = A + B$

- For example one can create a graph PROP G = SB + N, where SB (/special
  bialgebra/) gives the branching structure while $N$ is a /node/ PROP whose
  signature is a single $1 \mto 1$ morphism (node) and no equations.:
  So an example of morphism in $G = SB+N$ would be:
  
  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \includegraphics[width=4cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/prop_sum_graph_prop.pdf}
  #+END_EXPORT
  #+END_CENTER
  
  


** Set category
*** Monomorphisms (Sets)                                                                 :noanki:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
B \arrow[r, "g_1", bend left] \arrow[r, "g_2", bend right] \arrow[rr, "f \circ g_1", dotted, bend left=49] \arrow[rr, "f \circ g_2", dotted, bend right=49] & C \arrow[r, "f", hook] & D
\end{tikzcd}
#+END_EXPORT
#+END_CENTER
- $f$ is a monomorphism if $$\neg\exists (g_1, g_2) ~~ g_1 \neq g_2 \wedge f \circ g_1 = f \circ g_2$$

- If $f$ is not mono, one could find $g_1 \neq g_2$ for which
  $$f(a_1) = f(a_2) \rightarrow f \circ g_1 = f \circ g_2$$ 

*** Epimorphisms (Sets)                                                                 :noanki:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
B & C \arrow[l, "g_1"', bend right] \arrow[l, "g_2"', bend left] & D \arrow[l, "f"', tail] \arrow[ll, "g_1 \circ f"', dotted, bend right=49] \arrow[ll, "g_2 \circ f"', dotted, bend left=49]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- $f$ is an epimorphism if $$\neg\exists (g_1, g_2) ~~ g_1 \neq g_2 \wedge g_1 \circ f = g_2
  \circ f$$

- If $f$ is not surjective, there are elements in $C$ which will not participate
  to $g_{*} \circ f$ (/terra incognita/). There will be thus $g_1$ and $g_2$ that differ only in
  terms of those excluded terms while their composition is the same.

*** Terminal object (Sets)                                                                 :noanki:

There is a set 1 for which, for any set $X$, there is a unique function $X \rightarrow 1$.
This is called the *terminal object*.

*** Unit of categorical product (Sets)                                                                 :noanki:

The unit of a categorical product is the terminal object, $X \times 1 \simeq X$

*** Sets sharing an element (Sets)

If:

- there is a monomorphism $m: B \rightarrow X$

- and there is $k: 1 \rightarrow B$ such that $x: 1 \rightarrow X$ factors through $m$, i.e.,  $x = m \circ k$

then $x \in B$

*** Subobject (Sets)

Any object $B$ for which there exists a monomorphism $B \rightarrow X$ is a subset/subobject of $X$.

*** Equalizer (Sets)

Given two functions ($g_1, g_2: X \rightarrow Y$), *their equaliser* is an *object* and
*monomorphism* *pair* $(E,m: E \rightarrow X)$ for which the following
properties hold:

1. *Equivalence*: $g_1 \circ m = g_2 \circ m$
2. *Limit*: for any other object pair $(O,m_o: O \rightarrow X)$ where $g_1 \circ
   m_o = g_2 \circ m_o$, there exists a unique morphism $f: O \rightarrow E$ such
   that $m_o = m \circ f$

$E$ should be understood as the subset of elements of $X$ for which $g_1(x) =
g_2(x)$, i.e., the solutions of the equation.

*** Function objects (Sets)                                         :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

    - The object-morphism pair $(r^{p}, eval: p \times r^{p} \rightarrow r)$
      makes an *exponential object* if for all other object-morphism pair $(q, e)$ there exists 
      a mapping $\lambda(e)$ such that the following commutes:

      #+BEGIN_CENTER
      #+BEGIN_EXPORT latex
      \begin{tikzcd}
                                      & r &                                                               \\
      p \times r^p  \arrow[ru, "eval"] &   & p \times q \arrow[ll, "\lambda(e) \times id"] \arrow[lu, "e"] \\
      r^p                             &   & q \arrow[ll, "\lambda(e)"]                                   
      \end{tikzcd}
      #+END_EXPORT
      #+END_CENTER

    - the mapping $\lambda(e): q \rightarrow r^{p}$ is called the called
      *currying* of $e$. 

    - in fancy words, for every object $r,p$  the exponential is a universal arrow to $r$ of a
      functor $H[-] = p \times -$ 

*** Zero morphism
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- A left-zero morphism $0_{XY}$ is such that the following commutes for any $W, g, h$ 

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  Y & X \arrow[l, "0_{XY}"] & \forall W \arrow[l, "\forall g", bend left] \arrow[l, "\forall h"', bend right]
  \end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

- A right-zero morphism is such that the following commutes for any $Z,g,h$

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  \forall Z & Y \arrow[l, "\forall g", bend left] \arrow[l, "\forall h"', bend right] & X \arrow[l, "0_{XY}"]
  \end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

*** Kernel object
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- A kernel object of a morphism $f: X \rightarrow Y$ is the equalizer of $f$ and
  a right-zero-morphism $0_{XY}: X \mto Y$

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  \forall Z & Y \arrow[l, "\forall g", bend left] \arrow[l, "\forall h"', bend right] & X \arrow[l, "0_{XY}"] \arrow[l, "f"', bend right] \\
            &                                                                         & K_f \arrow[u, "k"] \arrow[lu, "0_{K_fY}"]        
  \end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

- In the category of groups, it is exactly the kernel of a morphism of groups

** Kleisly category and monads
*** Kleisly category ($C_T$) definition
    - Assume $C$ is a category with an endofunctor $T$ and a morphism $\mu: T^2 C \rightarrow C$
    - $C_T$ has the same object as $C$ but any morphism $A \rightarrow_T B$ is
      built by picking a morphism $A \rightarrow T B$ in the following way:
      - The *identity* for any $A$ is constructed by picking a morphism $\eta_A: A
        \rightarrow T A$
      - The composed arrow $h_T = f_T \circ g_T : A \rightarrow_T C$ is the
        the one built as $h: A \rightarrow T C$ such that $$ h = \mu
        \circ T f \circ g$$
      - Note that $T f: T B \rightarrow T^2 C$
    - The relationship between $C$ and $C_T$ is an example of /adjunction/
*** Monads 
    Given a category $C$, A monad corresponds to the data of:
    - an endofunctor $T: C \rightarrow C$
    - a unit natural transformation $\eta: 1_C \Rightarrow T$ (where $1_C$ is the identity endofunctor)
    - a multiplication natural transformation $\mu: T^2 \Rightarrow T$ arising
      from functor composition so that, seeing the endofunctors as objects in
      the monoidal category of endofunctors $C^C$, the unit and the
      multiplication can be used to make $T$ a monoid. Recall that,
      multiplication is functor composition.

*** Monads from adjoint functors 
:PROPERTIES:
:BEAMER_opt: fragile
:END:
:LOGBOOK:
CLOCK: [2018-07-26 Thu 11:19]--[2018-07-26 Thu 11:24] =>  0:05
:END:
#+BEGIN_EXPORT latex
\begin{tikzcd}
D~\textrm{with}~\epsilon: LR \rightarrow I_d \arrow[rr, "R(\textrm{ight})", bend right=49] & \bot & C~\textrm{with}~\eta: I_c \rightarrow R L \arrow[ll, "L(\textrm{eft})", bend right=49]
\end{tikzcd}
#+END_EXPORT
    - A monad is the shadow cast by an adjunction into the domain of the left-adjoint $C$.
    - It raises from natural transformations that one can build on the base functor $T=RL$.
    - The adjunction ensures that $\mu: RLRL \rightarrow RL$ is natural.
*** Monads from adjoint functors (Maybe monad)
:PROPERTIES:
:BEAMER_opt: fragile
:END:
:LOGBOOK:
CLOCK: [2018-07-26 Thu 11:19]--[2018-07-26 Thu 11:24] =>  0:05
:END:
#+BEGIN_EXPORT latex
\begin{tikzcd}
Set_{*} \arrow[rr, "R(\textrm{ight})~\textrm{forgetful}", bend right=49] & \bot & Set  \arrow[ll, "L(\textrm{eft}) ~ \textrm{free}", bend right=49]
\end{tikzcd}
#+END_EXPORT

- The left-adjoint is *free* and takes 
   - each set $S$ to $(S \cup \{\nu_S\}, \nu_S)$. 
   - each $f: S_1 \rightarrow S_2$ to a function $f^*$ such that $f^*(s)=f(s), f^*(\nu_A) = \nu_B$
- The right-adjoint maps to $S \cup \{\nu_S\}$ and $f^*$.
- $\eta = LR$ adds a new basepoint to the set and the natural transformation is given
  by natural inclusion.
- $\mu = LRLR$ map the two new points (because we have to LR in series) to a single
  given by $LR$.

*** Monad laws (left identity)
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

        #+BEGIN_EXPORT latex
        \begin{tikzcd}
        {T[A]} \arrow[d, "f^o"] & A \arrow[l, "r"] \arrow[ld, "f"] \\
        {T[B]} & 
        \end{tikzcd}
        #+END_EXPORT

     $f^o$ is the bound function. It should commute with the return of the monad.

*** Monad laws (right identity)
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:


        #+BEGIN_EXPORT latex
        \begin{tikzcd}
        {T[A]} \arrow[d, "r^o"] \arrow[d, "id"', bend right] & A \arrow[l, "r"] \arrow[ld, "r"] \\
        {T[A]} & 
        \end{tikzcd}
        #+END_EXPORT
     
    Bound return equals identity.

*** Monad laws (associativity)
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

        
        #+BEGIN_EXPORT latex
        \begin{tikzcd}
        {T[M]} \arrow[d, "f^o"] & M \arrow[ld, "f"] \\
        {T[M']} \arrow[d, "g^o"] & M' \arrow[ld, "g"] \\
        {T[M'']} & 
        \end{tikzcd}
        #+END_EXPORT

     $g^o \circ f^o = (g^o \circ f)^o$

*** Monad in a bicategory
:PROPERTIES:
:BEAMER_opt: fragile
:END:

*A monad on an object $x$* of the bicategory $B$ is a 1-cell $F: x \mto x$ with
2-cells $\eta$ and $\mu$ such that the following commute:


#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=10cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/bicategory_monad.pdf}
#+END_EXPORT
#+END_CENTER

If $B=Cat$, $x$ is a category and the above corresponds to the usual notion of
monad as an endofunctor. A monad morphism $\theta$ is a 2-cell making the
following commute:


#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=8cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/bicategory_monad_morphism.pdf}
#+END_EXPORT
#+END_CENTER

*** Monad in a bicategory: example of *Span(Set)*
- In $Span(Set)$, a monad $F$ on an object $Ob$ is a 1-cell (morphism) $Ob \lto
  Ar \mto Ob$; $\mu$ associates to each $f, g \in Ar$ their composition $f; g
  \in Ar$ while $\eta$ associates to each $x \in Ob$ an arrow $a \in ar$

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{figure}
  \subfigure{\includegraphics[width=5cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/spanset_mu.pdf}}
  \subfigure{\includegraphics[width=2cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/spanset_eta.pdf}}
  \end{figure} 
  #+END_EXPORT
  #+END_CENTER 

- Given a monad $F$ over two sets $Ob$ and $Ar$, these can be made into a small
  category $C_F(Ob,Ar)$.
  
*** Monad in a bicategory: example of *Span(Mon)*

- In $Span(Mon)$, where $Mon$ is the category of monoids and monoid homomorphisms,
  a monad over a monoid $m$ can be used to define a small strict monoidal category
  with objects the elements of $m$.
  
*** Monad in a bicategory: monad composition in *Span(Set)*

- Given to monads $F$ and $G$ over a single set $Ob$ and a 2-cell $\lambda: F;G
  \mto G;F$) respecting some additional rules and called /distributive law/

- Then one can create a monad $G;F$ over $Ob$

*** Indexed monad

Given categories C and D, a /D-indexed monad over C/ is a C-endofunctor $D^D \times C \mto C$ with two natural transformations:

$$\eta: [-] \mto T_{m}[-]$$
$$\mu: T_{m_2}[T_{m_1}[-]] \mto T_{m_2 \circ m_1}[-]$$
where $m_{*}$ is a morphism in the category $D$


 
** Functors
*** Functor definition                                                                 :noanki:

A functor \[ F : \mathcal{C} \rightarrow \mathcal{C'} \] is a pair $(F_o, F_m)$ where

- $F_o$ maps *each object* in $\mathcal{C}$ into an object in $\mathcal{C'}$, while

- $F_m$ maps *each morphism* in $\mathcal{C}$ with laws 

#+BEGIN_EXPORT latex
\begin{equation}
\begin{split}
  F(h \bullet g) & = F(h) \bullet F(g) \\
  F(id_o) & = id_F(o) \\
\end{split}
\end{equation}
#+END_EXPORT

*** Full functor                                                                 :noanki:

A *full functor* $T: C \rightarrow D$ is an *epimorphism* between morphisms in $C$ and $D$.

*** Faithful functor                                                                 :noanki:

A faithful functor $T: C \rightarrow D$ is a *monomorphism* between morphisms in $C$ and $D$.

*** Identity functor                                                                 :noanki:
    $Id: C \rightarrow C$ is a functor that maps an object to itself and a
    function to itself.

*** Constant $\Delta_c$ functor                                                                 :noanki:
    A constant functor $\Delta_c: B \rightarrow C$ is a functor that maps every
    object in $B$ into a single object $c \in C$ and every morphism into the
    identity map on $c$.

*** Bifunctors

- A bifunctor over $C$ and $D$ is a functor over pairs of objects and morphisms,
  i.e., $C \times D \rightarrow E$

- Products and co-products are special bifunctors $C \times C \rightarrow C$

*** Contravariant functors
:PROPERTIES:
:BEAMER_opt: fragile
:END:

    - A contravariant functor is a functor $C^{op} \rightarrow D$. It basically
      maps inverse arrows in $C$ to $D$.
      #+BEGIN_CENTER
      #+BEGIN_EXPORT latex
      \begin{tikzcd}
      c & Fc \arrow[d, "Ff"] \\
      c' \arrow[u, "f"] & Fc'
      \end{tikzcd}
      #+END_EXPORT
      #+END_CENTER

    - An example is the functor $F[-] = Q^{(-)}$ which is indexed by an object $Q$ and maps each object $c$ 
      to the set of morphisms from $c$ into $Q$.

      #+BEGIN_CENTER
      #+BEGIN_EXPORT latex
      \begin{tikzcd}
      c & Q^c \arrow[d, "Ff = \lambda q^c. q^c \circ f"] \\
      c' \arrow[u, "f"] & Q^{c'}
      \end{tikzcd}
      #+END_EXPORT
      #+END_CENTER

*** Profunctors

    A pro-functor is a functor $D^{op} \times C \rightarrow Set$. 

*** Combination of functors                                                                 :noanki:

    - $T(X) = X = Id$ is a functor

    - $T(X) = A = \Delta_A$ is a functor

    - If $F_1(X)$ and $F_2(X)$ are functors then $T(X) = F_1(X) + F_2(X)$ is a
      functor
    - If $F_1(X)$ and $F_2(X)$ are functors then $T(X) = F_1(X) * F_2(X)$ is a functor

    - If $F_1(X)$ is a functor then $T(X) = F_1(X)^A$ is a functor


    Thus any polynomial expression in an object $X$ can be made into a functor.

*** Curry-Howard-Lambek isomorphism                                                                 :noanki:


    | *Logic*          | $\top$   | $\bot$  | $a \wedge b$ | $a \vee b$ | $a \Rightarrow b$ |
    | *Types*          | ()       | Void    | (a,b)        | Either a b | $a \rightarrow b$ |
    | *C. C. Category* | terminal | initial | $a \times b$ | $a + b$    | $b^a$             |

    - Proving a logic predicate means constructing an element of a specific type

    - A cartesian closed category is a model for logic and category theory
*** Natural transformation of functors $F \rightarrow G$                                                                 :noanki:

    It is a way of comparing functors; given two functors $F,G: C \rightarrow D$, I
    can create compare them by :
    - picking to objects object $c_1,c_2$ and a morphism $f: c_1 \rightarrow c_2$
    - picking in $D$ a morphism $\alpha_{c_1}$ in $D$ that maps $Fc_1$ to $Gc_1$
      (the family of $\alpha_c$ is called *components of the NT*).
    - picking in $D$ a morphism $\alpha_{c_2}$ in $D$ that maps $Fc_2$ to $Gc_2$
    How can I detect any relation between $F,G$ meaning they are similar? This
    naturality condition is $$\alpha_{c_2} \circ F f = G f \circ \alpha_{c_1},
    \forall c_1,c_2$$

*** Natural transformation maps morphisms to ...                                                                 :noanki:

    A natural transformation maps a morphism to a commuting diagram (*naturality
    square*).

*** Natural isomorphims                                                                 :noanki:

    All the components of a NT are invertible

*** Category of functors and natural transformation                                                                 :noanki:
    - If I compose the components of two natural transformations $\alpha: F a
      \rightarrow G a$ and $\beta: G a \rightarrow H a$, do I have another
      natural transformation? yes
    - Is there an identity NT? yes, it is the family of identity morphisms $F a \rightarrow F a$
    - The category of functors from $C$ into $D$ is called $D^C$
    - In 'Cat', the morphisms between categories (functors) are not only a set but a category

*** Cells                                                                 :noanki:

- 0-cell is an object
- 1-cell is a morphism
- 2-cell is a morphism between morphisms

*** 2-category                                                                 :noanki:
- A class of 0-cells (objects): $A,B,C$ 

- For all 0-cells $A$ and $B$, there is a category of morphisms $C(A,B)$ where:

  - objects are the morphisms between $A$ and $B$ (called 1-cell)
  - morphisms are morphisms between morprhisms and are called 2-cells.

- Example: CAT, where 1-cells are functors and 2-cells are natural transformations

*** Natural transformation vertical composition                     :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given two nt. $\alpha,\beta \in \mathbb{D}^\mathbb{C}$ can create a new
nt. $\beta\alpha: \mathbb{D}^\mathbb{C}$ 

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A \in \mathbb{C} \arrow[d] & FA \in \mathbb{D} \arrow[d] \arrow[r, "\alpha_A"] \arrow[rr, "(\beta\alpha)_A", bend left=49] & GA \arrow[r, "\beta_A"] \arrow[d] & HA \arrow[d] \\
B \in \mathbb{C}           & FB \arrow[r]                                                                                  & GB \arrow[r]                      & HB          
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

It is done componentwise $$(\beta \alpha)_A = \beta_A \alpha_A$$


*** Natural transformation horizontal composition                   :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\mathbb{C} \arrow[r, "\Downarrow \alpha"', bend left=49] \arrow[r, "G", bend right=49] \arrow[r, "F", bend left=49] & \mathbb{D} \arrow[r, "\Downarrow \gamma"', bend left=49] \arrow[r, "K", bend right=49] \arrow[r, "H", bend left=49] & \mathbb{E} = & \mathbb{C} \arrow[r, "\Downarrow (\gamma * \alpha)"', bend left=49] \arrow[r, "KG", bend right=49] \arrow[r, "HF", bend left=49] & \mathbb{E}
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

For all $c \in \mathbb{C}$ $$(\gamma * \alpha)_c = \gamma_{Gc} \circ H\alpha_c = K\alpha_c \circ \gamma_{Fc}$$

When some ntt. are identities, these are called whiskerings, e.g., $H\alpha:
HF \mto HG$ for $\gamma=id$ is the whiskering of $\alpha$:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\mathbb{C} \arrow[r, "\Downarrow \alpha"', bend left] \arrow[r, "G"', bend right] & \mathbb{D} \arrow[r, "H"] & \mathbb{E}
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

It can be shown that $\gamma * \alpha$ can be decomposed into whiskerings of
either $\alpha$ or $\gamma$.




*** Bi-category example *Cat* 

- 0-cells are categories
- 1-cells are functors and they must compose (symbol used for composition is
  ";")
- 2-cells are natural transformations and they must compose 

*** Bi-category example *Span(C)* (up to 1-cells)

Assume C is a category with pullbacks. Then *Span(C)* is such that
- 0-cells are objects of C, 
- 1-cell $x \mto y$ is a span $(z, f: z \mto x, g: z \mto y)$; composition is given by pullback

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics{/Users/zaccaria/development/github/org-institutional/anki-cards/images/spanc_2cellcomp.pdf}
#+END_EXPORT
#+END_CENTER

*** Bi-category example *Span(C) (2-cells)*

- A 2-cell is a span morphism $h: z \mto z'$. 
- Horizontal composition of two 2-cell $h, h'$ is such that the diagram on the right commutes

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{figure}
  \subfigure{\includegraphics{/Users/zaccaria/development/github/org-institutional/anki-cards/images/spanc_2cell.pdf}}
  \subfigure{\includegraphics{/Users/zaccaria/development/github/org-institutional/anki-cards/images/spanc_2cellhcomp.pdf}}
  \end{figure} 
  #+END_EXPORT
  #+END_CENTER 

- Vertical composition (2-cells along one cells) is composition in $C$

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \includegraphics{/Users/zaccaria/development/github/org-institutional/anki-cards/images/spanc_2cellvcomp.pdf}
  #+END_EXPORT
  #+END_CENTER


*** Representable functors  
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
a \arrow[rr, "d^{(-)}", dashed] \arrow[rrr, "F(-)", dashed, bend left] &  & d^a \in \textbf{Set} \arrow[d] \arrow[r] & \cong d^a \arrow[d] \\
b \arrow[u] \arrow[rr, dashed] \arrow[rrr, dashed, bend right] &  & d^b \in \textbf{Set} \arrow[r] & \cong d^b
\end{tikzcd}
#+END_EXPORT
    - Given an object $d \in C$, we have a functor $d^{(-)}: C^{op} \rightarrow Set$ 

    - Given a generic contravariant functor $F: C^{op} \rightarrow Set$, we say that it is
      *representable* by $d$ if it is isomorphic to $d^{(-)}$.

*** Representable functor in Haskell

: class Representable f where 
:   type Rep f :: *                 -- this is d in (-)^d
:   tabulate :: (Rep f -> x) -> f x -- natt (-)^d -> f (-)
:   index :: f x -> (Rep f -> x)    -- other way around

- Works if you think about (~Rep f)~ as the index into the container (~f x)~.
  For example streams are representable while lists are not.
  ~tabulate~ creates the container, ~index~ extracts a value from a value
  of ~Rep f~.

- Another example is the matrix functor that is representable by a pair of integers. 
  A morphism from ~(int,int) -> a~ is one on one with a matrix ~Matrix a~.


*** Universal property of object $X$

- $X$ has a universal property when it represents a functor
- We say that the functor encodes the universal property of $X$.

*** Universal property of initiality

If there exists an object $X$ for which $(-)^X$ is isomorphic to the functor 

$$\textrm{sing} : (-) \mapsto \{ \cdot \}$$ 

that maps objects to the singleton set, then we say that $X$ is *initial.* We also
say that sing is representable by $X$.

*** Universal property of finality 

If there exists an object $X$ for which $X^{(-)}$ is isomorphic to the functor 

$$\textrm{sing} : (-) \mapsto \{ \cdot \}$$ 

that maps objects to the singleton set, then we say that $X$ is final.
This means that, the set of morphisms into $X$ from any other object is singleton.

*** Universal property encoded by $Id_{Set}: Set \rightarrow Set$
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Take $Id_{Set}$ as the *identity functor* in the category $Set$ then, in the
following diagram:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
x \in Set \arrow[d, "f"] \arrow[r, "Id_{Set}"] & x \arrow[d, "f"] \arrow[r, "\cong"] & x^? \arrow[l] \arrow[d, "f_*"] \\
y \arrow[r, "Id_{Set}"] & y \arrow[r] & y^? \arrow[l, "\cong"]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

The *singleton set* is the only value for (?) that represents $Id_{Set}$ because
only for that object there is a natural transformation that makes the right
square commute.

*** Universal property encoded by the forgetful functor $U: Grp \rightarrow Set$
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
G \arrow[d, "f"] \arrow[r, "U"] & S_G \arrow[d, "f_U"] \arrow[r, "\cong"] & G^? \arrow[l] \arrow[d, "f_*"] \\
H \arrow[r, "U"] & S_H \arrow[r] & H^? \arrow[l, "\cong"]
\end{tikzcd}
#+END_EXPORT

The only value for $?$ is the group $Z$. i.e., the *free group on a single
generator*. So $Z$ represents $U$. In fact, the set $G^Z$ is the set of
homomorphisms from $Z$ to $G$ whose size depends on which of the elements of $G$
we map the generator.


*** Universal arrow from object                                     :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
- A *universal arrow from object* $c \in C$ to $S$ allows to factor all morphisms $f'$ 
  through morphisms in the codomain of incoming functor $S: D \rightarrow C$.

- It is an object/morphism pair $(r, u)$ such that the following diagrams commute.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                    & c \arrow[ld, "u",red] \arrow[rd, "f'"] &  \\
Sr \arrow[rr, "Sh"] &                                        & Sd \\
r \arrow[rr, "h"]   &                                        & d \\
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

The universal arrow is also called *free object* on $c$.


*** Universal arrow from object (coslice category view definition)
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Given the functor $S: D \rightarrow C$, we can define a universal arrow from
object $c$ to $S$ as the initial object $\np{r}{u}$ in the coslice category $(c
\downarrow S)$

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                    & c \arrow[ld, "u",red] \arrow[rd, "f'"] &  \\
Sr \arrow[rr, "Sh"] &                                        & Sd \\
r \arrow[rr, "h"]   &                                        & d \\
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Universal arrow from object and representation
:PROPERTIES:
:BEAMER_opt: fragile
:END:
$(r, u)$ is universal for $(S,c)$ means that $(S-)^c$ *is represented* by $r$. 

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                    & c \arrow[ld, "u",red] \arrow[rd, "f' \in (S-)^c \cong r^-"] &  \\
Sr \arrow[rr, "Sh"] &                                        & S- \\
r \arrow[rr, "h"]   &                                        & - \\
\end{tikzcd}
#+END_EXPORT
#+END_CENTER





*** Universal arrow from object (free vector spaces)
:PROPERTIES:
:BEAMER_opt: fragile
:END:


- $U\KK[X]$ is the set of vectors in $\KK[X] = span(X)$.
- $j_X$ injects the basis into the whole set $U\KK[X]$. It is universal.
- Any (linear) $f: \KK[X] \rightarrow W$ can be defined by choosing $g$ (*extending
  it*) $$Uf \circ j_X = g$$

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                                         & X \arrow[ld, "j_x",red] \arrow[rd, "g"] &  \\
U\KK[X] \arrow[rr, "Uf"]                 &                                         & UW \\
\KK[X] \arrow[rr, "f (\textrm{linear})"] &                                         & W \\
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

$j_X$ could be thought of as the cases where the input parameter of $U_x$ are
just those in $X$. If $f$ is linear, it suffices to specify its value only for
those cases.

*** Universal arrow $S_G \mto S_{G/N}$ to forgetful $Grp \mto Set$ resp. kernels
:PROPERTIES:
:BEAMER_opt: fragile
:END:

$(\pi_{G,N}, G/N)$ is the universal arrow to $H: Grp \rightarrow Set$ (maps
respecting the kernel). Any mapping $x_k: S_G \rightarrow S_X$ can be fixed with
$f_k$. Or, fixing $x_k$ gives a group hom $f_k$.


#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                               & S_G \arrow[ld, "{\pi_{G,N}}"] \arrow[rd, "x_k(g)"] &     \\
S_{(G/N)} \arrow[rr]           & *                                                  & S_X \\
G/N \arrow[rr, "\exists!f_k"'] & * \arrow[u, "H_{/N}", dotted]                      & X  
\end{tikzcd}
#+END_EXPORT
#+END_CENTER



*** Universal arrow $S \mto US^*$ to forgetful $Set_* \rightarrow Set$
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
                               & S \arrow[ld, "i"] \arrow[rd, "x_k(g)"] &    \\
U(S^*) \arrow[rr]              & *                                      & UX \\
S^* \arrow[rr, "\exists!f_k"'] & * \arrow[u, "H_{*}", dotted]           & X 
\end{tikzcd}
#+END_EXPORT



*** Universal element 
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
             &                               & {*} \arrow[ld, "u"] \arrow[rd, "x_k"] &    \\
\mathbb{SET} & HU \arrow[rr]                 & *                                     & HX \\
\mathbb{U}   & U \arrow[rr, "!\exists f_k"'] & * \arrow[u]                           & X
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Assume a functor $H: \mathbb{U} \rightarrow \mathbb{SET}$.
$(U, u)$ is a universal element of $H$ if, for every element $x_k$ in $HX$
there exists a unique $f_k$ such that the above diagram commutes. 
Practically, it enables a unique correspondence between elements of a set and morphisms.


*** Universal element (Sets and equivalence relations)
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- Given an equivalence relation $E$ over $f$, the familiar mapping $p: S
  \rightarrow S/E$ is a /universal element/ of the functor 
  $H_{/E}$ which maps to morphisms of maps preserving the equivalence relation.

- $p$ is universal, because for any element $x_k$ there exists a unique $f_k$
  such that this diagram commutes:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                               & \{*\} \arrow[ld, "p"] \arrow[rd, "x_k(s)"] &          \\
(S/E)^S_{/E} \arrow[rr]        &  *                                         & X^S_{/E} \\
S/E \arrow[rr, "\exists!f_k"'] &  * \arrow[u, "H_{/E}", dotted]               & X
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Universal element (Groups and quotients) 
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given a functor $H=(-)^G_N : Grp \rightarrow Set$ giving the sets of homomorphisms from $G$ for which
$fN=1$ and $p$ as the mapping into cosets $G \rightarrow G/N$ then $(G/N,p)$ are
a universal element of $H$.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                               & \{*\} \arrow[ld, "p"] \arrow[rd, "x_k(g)"] &          \\
(G/N)^G_{/N} \arrow[rr]        & *                                          & X^G_{/N} \\
G/N \arrow[rr, "\exists!f_k"'] & * \arrow[u, "H_{/N}", dotted]              & X       
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

In practice, considering only morphisms respecting the kernel, 
$X^G \simeq X^{G/N}$ because $p: G \mto G/N$ is part of all of them.





*** Universal arrow vs universal element
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
 & * \arrow[ld] \arrow[rd] &  \\
HU = \{ ... u ... \} \arrow[rr, "Hf"] &  & HX=\{...x...\} \\
U \arrow[rr, "f"] &  & X
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Considering the category of pointed sets and a generic functor, a universal
element $(U,u)$ is exactly a universal arrow from $*$ to $H$.

Seeing this as a coslice category $(1 \downarrow Set)$, every morphism $1 \rightarrow HX$ is 
in direct correspondence with $f_x$ if it makes the coslice category diagram commute.

*** Universal arrow to object
:PROPERTIES:
:BEAMER_opt: fragile
:END:
- A *universal arrow to object* $c \in C$ from $S$ is an object/morphism pair $(r,
  v)$ such that, in the following diagram, for any $f$ there is an $f'$ such
  that it commutes

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
 & c &  \\
Sr \arrow[ru, "v"] &  & Sd \arrow[ll, "Hf'"] \arrow[lu, "f"] \\
r &  & d \arrow[ll, "f'"]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Universal arrow to object, product example
:PROPERTIES:
:BEAMER_opt: fragile
:END:


#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
 & a \times b \arrow[ld, "p"] \arrow[rd, "q"] &  &  & {\langle a, b \rangle} &  \\
a & c \arrow[u, "h"] \arrow[l, "f"] \arrow[r, "g"'] & b & \Delta (a \times b) \arrow[ru, "{\langle p, q \rangle}"] &  & \Delta c \arrow[ll, "{\langle h, h \rangle}"] \arrow[lu, "{\langle f, g \rangle}"'] \\
 &  &  & a \times b &  & c \arrow[ll]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Projection functions $\ang{p, q}$ from the product $a \times b$ (and the product itself) are
the universal arrow from the functor $\Delta(c) = \ang{c,c}$ to the object $\ang{a,b}$.

*** Presheaf
A presheaf on a small category $C$ is a functor $$C^{op} \mto Set$$. The category
of presheaves on $C$ is denoted as $[C^{op}, Set]$ and has functors as objects 
and natural transformations as morphisms.

** Monad algebras
*** Drawbacks of F-algebras                                                                 :noanki:

- Given an algebra $(X, \theta: T(X) \rightarrow X)$, with $T(X) = 1 + X^2$ we
  know that $\theta$ has the same signature of a monoid but it should not abide
  by its laws. Not every such algebra is a monoid.

- Monad algebras can help enforce additional structure on functor algebras

*** Monad algebras
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given a monad $(T,\eta,\mu)$, a *monad algebra* is an algebra of the underlying functor $(X,\theta)$ where,
additionally, the following diagrams commute:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
T(T(X)) \arrow[d, "T\theta"] \arrow[r, "\mu"] & T(X) \arrow[d, "\theta"] & X \arrow[l, "\eta"'] \arrow[ld] \\
T(X) \arrow[r, "\theta"] & X \arrow[ru, "\cong"] & 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- The *Eilenberg-Moore* category is built with object $(X,\theta)$ that respect
  the above laws (morphisms are F-algebra morphisms).

- Practically, a monad algebra enforce monoidal laws on $\theta$.


** Natural transformations
*** Natural transformations and parametric polymorphism
    - In PP, I must use a single expression for a parametric function
    - A lot of parametric polymorphic functions ~F a -> G a~ are natural
      transformations by default (theorems for free) and can be used to optimize
      code, e.g.: $$safeTail \circ fmap~f = fmap~f \circ safeTail$$
    - Note, typeclasses represent /ad-hoc/ polymorphism.
    - The return of a monad is a natural transformation
** Adjunctions 
*** Adjoint functors 
:PROPERTIES:
:BEAMER_opt: fragile
:END:
:LOGBOOK:
CLOCK: [2018-07-26 Thu 11:19]--[2018-07-26 Thu 11:24] =>  0:05
:END:
#+BEGIN_EXPORT latex
\begin{tikzcd}
D~\textrm{with}~\epsilon: LR \rightarrow I_d \arrow[rr, "R(\textrm{ight})", bend right=49] & \bot & C~\textrm{with}~\eta: I_c \rightarrow R L \arrow[ll, "L(\textrm{eft})", bend right=49]
\end{tikzcd}
#+END_EXPORT
    - Two categories $C$ and $D$ are equivalent if I can build two functors, one
      going left $L: D \leftarrow C$ and $R: D \rightarrow C$ if their
      composition is naturally isomorphic, through $\eta$ and $\epsilon$, to the
      identity functor.
    - We say that $L$ is /left adjoint/ to R
*** Adjoint functors and homsets
    - It is another way of stating that two functors $L: D \leftarrow C$ and $R:
      D \rightarrow C$ are adjoint by comparing homsets $$D(L c, d) \cong C(c, R
      d)$$ for all $c,d$.
    - If this happens, then $$C(c,RLc)\cong D(Lc, Lc)$$ but $C(c, RLc)$ is our
      family of mappings/natural transformation $\eta$, if it exists. And it
      does, because $D(Lc,Lc)$ is not empty.

*** List monad from adjoint functors
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- $L$ maps a set $X = \{ x_i \}$ into the free monoid of words built 
  by mapping each element into a letter $\ang{x_i}$.
- $U$ is the forgetful functor that produces a set of words $\{ \ang{a},
  \ang{b}, \ang{ab} \dots\}$ forgetting multiplication.

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  \textbf{Mon} \arrow[r, "U"', bend right] & \textbf{Set} \arrow[l, "L"', bend right]
  \end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

- The adjunction $L \ladjof U$ produces the list monad $T=UL$ over set where:

  - $\eta_X$ maps each $x \in X$ to $\ang{x}$ in $ULX$ (the set produced by the
    forgetful functor).
  - $\mu_X$ flattens the list, e.g., $\mu_X(\ang{a\ang{ab}}) = \ang{aab}$


*** Yoneda lemma                                                    :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Lemma's says how many natural transformations between a representable presheaf 
and another presheaf $F$, i.e., the set:

$$Hom((-)^c,F)$$

If $\alpha$ is a natural transformation then the following must commute also for
$x=c$ and $x^c=Id_c$:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
x \arrow[d, "\phi"] & x^c \arrow[d, "\circ \phi"] \arrow[r, "\alpha_x"] & Fx \arrow[d, "F\phi" ] \\
y  & y^c \arrow[r, "\alpha_y"] & Fy
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

$$\alpha_y (\phi \circ Id_c) \simeq \alpha_y(\phi) = (F \phi) \alpha_c(Id_c)$$

Given $F$, for any $\alpha_c(Id_c) \in Fc$ there is a single $\alpha_y$. In practice: 
$$Hom((-)^c,F) = Fc$$



*** Pre - Yoneda Lemma - G-Equivariant maps
:PROPERTIES:
:BEAMER_opt: fragile
:END:
 Given two actions of a group $G$ (interpreted as functors) over two sets $X$
 and $Y$, a natural transformation among them is called a *$G$ equivariant map* $\alpha$

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\bullet (BG)  \arrow[d] & X \arrow[d, "g_*"] \arrow[r, "\alpha"] & Y \arrow[d, "g_*"] \\
\bullet  (BG)            & X \arrow[r, "\alpha"]                  & Y                 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Pre - Yoneda Lemma - Representability of functor from $BG$ to $G$
:PROPERTIES:
:BEAMER_opt: fragile
:END:

$\vert G \vert$ can be seen as an object in Set over which $BG$ acts functorially by left or right
multiplication ($g\times \cdot$), call this functor $\Gamma$. 

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\bullet (BG)  \arrow[d, "g"] & \vert G \vert \arrow[d, "\Gamma g = (g \times \cdot)"]  \\
\bullet (BG)           & \vert G \vert                
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Note that:
- $G \simeq (\bullet)^{\bullet}$
- there exists an inclusion from $\vert G \vert=\Gamma \bullet$ into $G = (\bullet)^{\bullet}$ which is natural and bidirectional

Functor (or action) $\Gamma$ is thus represented by $\bullet$.

*** Pre - Yoneda lemma - $G$ equivariant maps determined by identity
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\bullet (BG)  \arrow[d] & (\bullet)^{\bullet} \arrow[d, "(g \times \cdot)"] \arrow[r, "\alpha"] & F\bullet \arrow[d, "g_*"] \\
\bullet (BG)           & (\bullet)^{\bullet} \arrow[r, "\alpha"]                  &  F\bullet
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- Consider two actions of $G$: $\Gamma$ (represented by $\bullet$, so $\Gamma g =
  g \times \cdot$) and $F$.

- Any $G$ equivariant map $\alpha$ is completely determined by $\alpha(1)$ because
  $\alpha(g \times h) = g^*(\alpha(h))$ i.e. $\alpha(g) = g^*(\alpha(1))$

- There is thus a bijection between $$Hom(\Gamma, F) \simeq
  Hom((\bullet)^\bullet,F) \simeq F\bullet$$




*** Functor representability as universal arrow from the singleton set
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Any functor $(K-)^*:=K$ is *represented* by $r$ if $(r, u: * \rightarrow Kr)$ is
universal for $(K,*)$.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                    & * \arrow[ld, "u",red] \arrow[rd, "f' \in (K-)^* \cong -^r"] &  \\
Kr \arrow[rr, "Kh"] &                                        & K- \\
r \arrow[rr, "h"]   &                                        & - \\
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Yoneda: the components of the natural transformation $r^- \cong K-$ are one to one with the
elements of $Kr$.
*** Cayley's through yoneda                                                                 :noanki:

- Take $C = \{ * \}$ the category with a single object.

- Consider that $F = (-)^*$ so we have that $$(*)^* \cong Nat((-)^*, (-)^*)$$.

- But, $(*)^*$ is actually a group $G$ and it can be shown that $Nat(...)$ is actually a subgroup of permutations in
  $S_n$.

** Limits theory
*** Diagram functors                                                                 :noanki:
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

- In any category $C$, I can pick objects by expressing a *pattern*, i.e., through
  another (small) *index* or *shape* category $J$ and any functor $D: J \rightarrow C$ (diagram
  functor). 


*** Cone
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
 &  &  &  &  & c \arrow[ld, "\lambda_{c,A}"] \arrow[d, "\lambda_{c,B}"] \arrow[rd, "\lambda_{c,C}"] &  \\
A \arrow[r] \arrow[rrrr, dotted, bend right] \arrow[rrrrru, "\Delta_c" description, dashed] & B \arrow[rrrr, "D"', dotted, bend right] \arrow[rrrru, dashed] & C \arrow[l] \arrow[rrrr, dotted, bend right] \arrow[rrru, dashed] &  & i \arrow[r] & j & k \arrow[l]
\end{tikzcd}
#+END_EXPORT

- A cone over a diagram $D$ is built over natural transformations $\lambda$
  between the constant functor $\Delta_c$ and $D$ (both from the index category
  $S$).

- Consider each family $\lambda_{c,-}$ of morphisms with apex $c$, we define
  $Cone(c,D)$ as the set $\{ \lambda_{c,-} \}$ (as there can be more than one
  family).

*** Limit cone
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
- \arrow[rd, dotted] \arrow[rdd, dashed, bend right] \arrow[rrdd, dashed, bend left] &                        &         \\
                                                                                     & d \arrow[rd] \arrow[d] &         \\
                                                                                     & \bullet                & \bullet
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

# #+BEGIN_EXPORT latex
# \begin{tikzcd}
# c \arrow[rr, "{Cone(c,D)}"] &  & \{\lambda_{c,-}\} \in Set \arrow[d] \\
# c' \arrow[u, "m"] \arrow[rr, "{Cone(c',D)}"] &  & \{\lambda_{c',-}\} \in Set 
# \end{tikzcd}
# #+END_EXPORT

- $Cone(-,D): C^{op} \rightarrow Set$ is a functor. If there exists an object $d
  \in C$ for which $Cone(-,D) \cong d^{(-)}$, we say that $d$ is the limit of
  $D$ and the cone that departs from it is the /limiting cone/.

- In practice, if $d$ is a limit then for each morphism that arrives to it, there
  is a *single corresponding cone* from the sources of the morphism.

*** Limit cone (in Sets)
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
- \arrow[rd, dotted, "m"] \arrow[rdd, dashed, bend right] \arrow[rrdd, dashed, bend left] &                        &         \\
                                                                                     & d \arrow[rd] \arrow[d] &         \\
                                                                                     & \bullet                & \bullet
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- Recall that if $d$ is a limit then for each morphism $m \in d^{(-)}$, there is a
  *single corresponding cone* $c \in Cone(-,D)$ (i.e., from the sources of the
  morphism).

- In Set, if 1 is the singleton set we must have, e.g, $d^1 \cong Cone(1,D)$
  which means that $d$ is $Cone(1,D)$. So $$Cone(-,D) \cong Cone(1,D)^{(-)}$$

*** Products as limit 
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
 &  &  &  & c \arrow[d, "!\exists"] &  \\
 &  &  &  & lim~D \arrow[ld] \arrow[rd] &  \\
1 \arrow[rrr, "D"', dotted, bend right] \arrow[rrrru, dashed] & 2 \arrow[rrrr, dotted, bend right] \arrow[rrru, dashed] &  & i &  & j
\end{tikzcd}
#+END_EXPORT

- Consider a discrete category of only two object as the index category $S$.

- Any functor $D: S \rightarrow C$ *indexes a generic pair* of objects $(i,j)$
  (there are no choices in terms of morphisms to map) so we can speak of /the/
  functor $D$. MacLane goes as far as saying that $D$ *is a pair of objects*
  $(i,j)$.

- A product object $i \times j$ is the limit of a diagram $D$ built over the 
  above index category.

*** Terminal object as limit 
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
c'' \arrow[rd] & c \arrow[d] & c' \arrow[ld] \\
 & lim~D & 
\end{tikzcd}
#+END_EXPORT
    
A terminal object is the limit of apices of cones built over an empty index category.

*** Equalizer as limit
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
 &  &  &  & c \arrow[d, "!\exists"] &  \\
 &  &  &  & lim~D \arrow[ld] \arrow[rd] &  \\
1 \arrow[rrr, "D"', dotted, bend right] \arrow[rrrru, dashed] \arrow[r, bend left] \arrow[r, bend right] & 2 \arrow[rrrr, dotted, bend right] \arrow[rrru, dashed] &  & X \arrow[rr, bend left, "f"] \arrow[rr, bend right, "g"] &  & Y
\end{tikzcd}
#+END_EXPORT 

The equalizer of two morphisms $f,g$ is the limit of the above diagram. In Set, it is a subset of $X$
such that $f(x) = g(x)$.

*** Pullback (fibered product)
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
            &                    & c \arrow[rd] &                                     &                  \\
            & \textrm{Index Cat} &              & lim~D \arrow[d, "p"] \arrow[r, "q"] & B \arrow[d, "g"] \\
1 \arrow[r] & 2                  & 3 \arrow[l]  & A \arrow[r, "f"]                    & C               
\end{tikzcd}
#+END_EXPORT

- The *pullback* *of two morphisms* $f,g$ is a limit object $lim~D$ and two morphisms
  $p,q$ such that $f \circ p = g \circ q$. In Set, consider that $lim~D$ is the
  set $Cone(1,D)$. The pullback would be $$A \times_C B = \{ (a,b) = f(a) = g(b) \}$$

- If one uses fibers in $A$ and $B$ to make $f,g$ injective then
  $lim~D$ would be the product of fibers.

*** Pushout (fibered sum)
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_EXPORT latex
\begin{tikzcd}
c &                    &                                 \\
  & colim~D \arrow[lu] & B \arrow[l, "q"]                \\
  & A \arrow[u, "p"]   & C \arrow[l, "f"] \arrow[u, "g"]
\end{tikzcd}
#+END_EXPORT

- The *pushout of two morphisms* $f,g$ is a co-limit object $colim~D$ and two
  morphisms $p,q$ such that the above commutes.

- For sets, $colim~D$ is the disjoint union of $A$ and $C$ where elements of
  $A$ and $B$ that are the image of the same $c \in C$ map to the same
  element in $colim~D$. 
- When $f,g$ are inclusion maps (so $c \in C$ belongs to 
  both $A$ and $B$), this is the canonical set union $A \cup B$.


*** Fiber                                                           :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
 - A *fiber* of a function $f$ and a value $b$ is the set of elements:
   $$\phi_f(b) = \{ a | f(a) = b \}$$

 - It is a way to make some arbitrary function as injective; it corresponds to the
   following pullback:

   #+BEGIN_CENTER
   #+BEGIN_EXPORT latex
   \begin{tikzcd}
   \phi_f = A \times_B * \arrow[d] \arrow[r] & * \arrow[d, "pt"] \\
   A \arrow[r, "f"]                 & B                
   \end{tikzcd}
   #+END_EXPORT
   #+END_CENTER
  



* Haskell, functor algebras, free monads 
** Functor algebras and co-algebras
*** Definition of algebras and co-algebras                                                                 :noanki:
    - An algebraic operation in domain $X$ is a morphism from tuple objects to $X$
      e.g.: $$ X \times A
      \rightarrow X$$ or $$ A \rightarrow X $$

    - A co-algebraic operation in domain $X$ is a morphism from $X$ into a tuple
      object, possibly containing $X$: $$ X \rightarrow A \times
      X $$

*** Functoriality of products, coproducts, exponential and powersets                                                                 :noanki:

    - The product operation in a category $C$ is a bi-functor $(-) \times (-): C
      \times C \rightarrow C$ (it maps both *pairs of objects* to a *product object*
      and *pairs of functions* to a *product function*).

    - Fixed an object $A$ there is a functor $(-)^A: C \rightarrow C$ that maps $X$
      into $X^A$ (the exponential object).

    - The identity map is (endo-)functorial as well as the endomap that maps $X$
      into a fixed object.

*** How to build morphisms of polynomial functors with respect to original morphism                                                                 :noanki:

    - If we can build functors for products and coproducts, we can build functors
      also for their combination;

    - For example: $T(X) = X + (C \times X)$
      maps X to an object $X + (C \times X)$ but also morphisms $f: X \rightarrow X'$:

      $$T(f) = f + (id_C \times f): X+(C\times X) \rightarrow X'+(C \times X')$$

*** Functors mapping to 1 and 0                                    :noanki:

    - $X \rightarrow 1$ is the functor that maps $X$ into the singleton set (final object)

    - $X \rightarrow 0$ is the functor that maps $X$ into the emtpy set (initial object)

*** Functor algebra                                                                 :noanki:

    Given a polynomial (endo-)functor $T$ that maps $X \in C$ to $T(X) \in
    C$, a functor algebra for $T$ is a pair $(U,a)$:

    - an object $U \in C$ (*carrier*)
    - a morphism $a: T(U) \rightarrow U$ (*algebra structure*)

    $a$ must be defined by a cotuple of several functions whose signature is
    specified by $T$. For example, $$T(X) = 1 + X + (X \times X)$$ defines $$e:
    1 \rightarrow U, i: X \rightarrow X, m: (X \times X) \rightarrow X$$ which
    might encode the signature of group operations.

*** Functor algebra example - natural numbers                                                                 :noanki:

    $0$ and $S$ maps over natural numbers can be seen as a functor algebra
    $([0,S],\mathbb{N})$ of the functor $T(X) = 1 + X$.

*** Homomorphisms of algebras

    Given two T-functor algebras $(U, a: T(-) \rightarrow -)$ and $(V, b: T(-) \rightarrow -)$,
    a homomorphism of algebras from $(U,a)$ to $(V,b)$ is a function $f: U \rightarrow V$ which commutes
    with the operations $$ f \circ a = b \circ T(f)$$

*** Whole point of (co-)algebras                                                                 :noanki:
    - define functions indirectly exploiting fixed (co-)algebraic constructors
      and finality/initiality
    - so one has to specify only the initial algebra $A$ and another algebra $B$
      and automatically the morphism can be built. In general, the morphisms
      used by $B$ are not recursive.

*** Initial algebras                                                                 :noanki:
    - Fixed a functor $T$, functor algebras $(U, a: T(U) \rightarrow U)$ can be
      seen as categorical objects with algebra homomorphisms as morphism.

    - In this category, an *initial algebra* is an algebra for which there exist
      one and only one morphism from it to all the other algebras.

*** Lambek's lemma                                                                 :noanki:
    if $a: T(U) \rightarrow U$ is an initial algebra then there is an
    inverse $a^{-1}: U \rightarrow T(U)$ such that $T(U) \simeq U$.

*** An initial algebra defines homomorphisms by induction (integers)                                                                 :noanki:

    - Let's indicate with $(N, [0,S]: 1 + N \rightarrow N$) the *initial* algebra of
      natural numbers.

    - An object $Q$ equipped with a functor algebra $$(Q, [q_0,q_S]:
      1+Q\rightarrow Q)$$ defines, by induction, one and only one algebra
      morphism $f: N \rightarrow Q$.

      - $f \circ 0 = q_0$
      - $f \circ S = q_S \circ f$

      i.e, $$f = n \mapsto q_S^n(q_0)$$

*** An initial algebra defines homomorphisms by induction (lists)                                                                 :noanki:

    * Let's indicate with $(A^*, [e,c]: 1 + A \times A^* \rightarrow A^*$) the
      *initial* algebra of lists of $A$.

    * An algebra $$(Q^*, [q_e,q_c]:
      1+A \times Q^* \rightarrow Q^*)$$ defines, by induction, one and only one algebra
      morphism $f: A^* \rightarrow Q^*$.

      - $f \circ e = q_e$
      - $f \circ c = q_c \circ (id \times f)$

    * For example, an algebra $$(\mathbb{N}, [0, S \circ \pi]: 1+A \times
      \mathbb{N} \rightarrow \mathbb{N})$$ defines implicitly the length of a list

*** Proofs by induction with initial algebras (integers)            :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
1 + P \arrow[r, "1 + i"] \arrow[d] & 1 + N \arrow[d] \\
P \arrow[r, "i", hook] & N \arrow[l, "!\exists", bend left]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Assume that
- Predicate $P$ is a subset of $N$ by an inclusion morphism $i$. 

- ($0 \in P$ and $n \in P \Rightarrow (n+1) \in P$) means there exists an algebra for $P$.

Then, $i$ is an algebra morphism because the square commutes. Since there is
only algebra morphism from $N$ to $N$ (id) this means that $i$ must be an
epi-morphism.

*** Proofs by induction with initial algebras (lists)               :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
1 + A \times P \arrow[r, "1 + i"] \arrow[d, "-:-"] & 1 + A \times A^* \arrow[d, "-:-"] \\
P \arrow[r, "i", hook] & A^* \arrow[l, "!\exists", bend left]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Assume that: 
- $\phi$ is an algebra (it is if $p \in P \implies a:p \in P$)
- $i$ is an algebra morphism; it is because $i(a:p) = a:i(p)$
  
Then $i$ must belong to the unique identity morphism on $A^*$ so it is an
epimorphism.

*** Fixed point functors                                            :focus:
    - Initial algebras for some functors are already known. If we start from a
      generic functor $t$, the type of an initial algebra $\tia$ should be such 
      that $\tia \cong \tfun{\tia}$ (Lambeck).
    - Call $\tia \simeq Fix~t$ we have $Fix~t = t~(Fix~t)$, which in Haskell can
      be created through a recursive data type ~Fix t = Fix t (Fix t)~. ~Fix~ encodes 
      algebraic operations $\tfun{\tia} \rightarrow \tia$.
*** Catamorphisms                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\tfun{\tia} \arrow[r, "t~g"] \arrow[d, "Fix~(\textrm{unfix})", no head] & t~E \arrow[d, "k"] \\
\tia \arrow[r, "g"] & E
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


    - Given an initial algebra $(I, Fix: t~I \rightarrow I)$ and a generic algebra $(E, k)$, a
      generic morphism $g: I \rightarrow E$ can be defined as $g = k \circ (t~g) \circ unfix$
    - We say that $g = cata(k)$; given the same expression in $I$, I can create
      mappings into several other types by simply specifying the non-recursive
      $k$.

*** Scan (as a catamorphism)                                        :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given $\phi: A \times B \mto B$, $scan(\phi)$ is a catamorphism of type:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
1 + A \times A^* \arrow[d] \arrow[r] & 1 + A \times B^* \arrow[d, "{[1 , cons \circ \langle \phi, Id\rangle]}"] \\
A^* \arrow[r, "scan(\phi)"]          & B^*                                                              
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Catamorphisms fusion law                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
& {(I_t, fix)} \arrow[ld, "\kappa(f)"] \arrow[rd, "\kappa(h_{g,f})"] &         \\
{(F, f)} \arrow[rr, "g"] &                                                              & {(H,h_{g,f})}
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

# Vedere https://www.cs.ox.ac.uk/ralf.hinze/publications/IFL10.pdf

- Given $g$ and $f$, if there exists an $h_{g,f}$ such that $g$ is an algebra morphism, 
  the composition of $g \circ \kappa(f)$ is equal to $\kappa(h_{g,f})$.
  
- For example, for $I_t$ a list, $\kappa(f) = fold (+1) = length$ and $g = (2*)$ then $(2*) \circ
  length$ can be rewritten as the fold of $(+n)$, instead of $(+1)$.
- For a list this happens if one can find a $h_{g,f}$ such that $$(g \circ
  f)(a,n)=h_{g,f}(a,f(n))$$


*** Catamorphism compose law                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                                & t I_t \arrow[rd, "h"]                           &                                                 & t I_t \arrow[rd, "t~\kappa(f)"] &                       \\
t I_t \arrow[ru, "t~\kappa(h)"] &                                                 & I_t \arrow[rd, "\kappa(f)"] \arrow[ru, "unfix"] &                                 & t I_t \arrow[ld, "f"] \\
                                & I_t \arrow[ru, "\kappa(h)"] \arrow[lu, "unfix"] &                                                 & I_t                             &                      
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Since $Unfix \circ h$ is a natural transformation $$f~(t~\kappa(f))~ 
unfix ~h~ (t~\kappa(h))= (f ~ unfix ~ h)~
(t~(\kappa(h) \kappa(f)))$$ This means that $$\kappa(f) \circ
\kappa(h) = k(f \circ unfix \circ h)$$

- If $I$ is an expression type, and $h$ and $f$ are optimizations expressed as
  F-algebras, you can do a single optimization pass by composing their algebras:
  Another example,
- Or, $h$ could filter away data.

*** Combining algebras $(A, \phi), (B, \psi)$ into $(A \times B, q$ (banana split)                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Given $\phi: \tfun{a} \rightarrow a$ and $\psi: \tfun{b} \rightarrow b$ produce $\beta: \tfun{(a \times b)} \rightarrow (a \times b)$ as
$$\beta = (\phi \times \psi) \circ (t~fst \times t~snd) \circ split$$

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\tfun{\tia} \arrow[d] \arrow[r] \arrow[rr, bend left] \arrow[rrr, bend left] & \tfun{a} \arrow[d, "\phi", red] & \tfun{b} \arrow[d, "\psi", red] & \tfun{(a \times b)} \arrow[d, "(t~fst \times t~snd) \circ split" description, blue] \\
\tia \arrow[u] \arrow[r] \arrow[rr, bend right] \arrow[drrr, bend right] & a & b & \tfun{a} \times \tfun{b} \arrow[d, "\phi \times \psi" description, blue] \\
 &  &  & {a \times b}
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


      
*** Hylomorphisms                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
- Given a initial and final algebra of the same functor $t$
      $$hylo(\psi,\phi) = cata(\phi) \circ ana(\psi)$$

- This is the basis for deforestation, it eliminates intermediate data structures.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{\tfun{A}} \arrow[r]                                                                           & {\tfun{\tia}} \arrow[r] \arrow[d, no head] & {\tfun{B}} \arrow[d, "\psi"] \\
A \arrow[u, "\phi"] \arrow[r, "\alpha(\phi)"] \arrow[rr, "{hylo(\psi, \phi)}", bend right] & \tia \arrow[r, "\kappa(\psi)"]         & B                       
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- allows to exploit parallelism? substituting recursive control with a data structure

*** Hylomorphism example: mergesort                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{t_A[L_A]} \arrow[r]                                                                           & {t_A[\tia]} \arrow[r] \arrow[d, no head] & {t_A[L_A]} \arrow[d, "\psi"] \\
L_A \arrow[u, "\phi"] \arrow[r, "\alpha(\phi)"] \arrow[rr, "{hylo(\psi, \phi)}", bend right] & \tia \arrow[r, "\kappa(\psi)"]         & L_A                       
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- Consider the functor $t_A[X] = A + X \times X$, its initial algebra $\tia$ being a binary tree of $A$'s.
- Consider $L_A$ as a list of A's. One could implement merge sort $\mu: L_A
  \rightarrow L_A$ as $hylo(\psi,\phi)$, where $\phi$ constructs the tree by splitting
  lists in two while $\psi$ merges two lists into one (by reordering them).

*** Paramorphisms                                                   :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\tfun{\tia} \arrow[d] \arrow[r]                          & \tfun{\tia\times Z} \arrow[d, "{\langle Fix \circ t~fst, \phi \rangle}"] \\
\tia \arrow[u] \arrow[r] \arrow[rd, "para(\phi)"'] &  \tia \times Z \arrow[d, "\pi_Z"]                                     \\
                                                & Z                                                                
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Example, for factorial $f(i,z) = i~?~z*i:1$. Exercise, try to devise a para for sliding window.

*** Apomorphisms                                                    :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
t~(C + \fia) \arrow[r]                                     & t~\fia          \\
C+\fia \arrow[u, "{[\phi , t~Inj_R \circ cofix]}"] \arrow[r, "\alpha(\ldots)"]  & \fia \arrow[u] \\
C \arrow[ru, "\alpha_{po}\phi"] \arrow[u, "Inj_L"]      &             
\end{tikzcd}
#+END_EXPORT
#+END_CENTER
 
Given a co-algebra $\phi: C \mto t (C + \fia)$ where $\fia$ is final, it allows to
build a morphism $C \rightarrow \fia$ that short-circuits the traversal by giving
the result immediately. 

*** Apomorphisms example: streams :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A\times(A + S_A) \arrow[r]                             & A \times S_A \arrow[d, no head] \\
A+S_A \arrow[u, "{[\phi, t Inj_R \circ cofix]}"] \arrow[r] & S_A                             \\
A \arrow[ru, "apo(\phi)"] \arrow[u, "Inj_L"]           &                                
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

$\phi$ can return either $A \times A$ (becoming a generator) or $A\times S_A$
and at that point the ~cofix~ part starts.

*** Zygomorphism                                                    :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Applies algebra $\psi$ to $\tia$ instead of the initial one.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\tfun{\tia} \arrow[d] \arrow[r]                                  & t(\tia\times Z) \arrow[d, "{\langle \psi \circ t~fst, \phi \rangle}"] \\
\tia \arrow[u] \arrow[r] \arrow[rd, "{zygo(\psi, \phi)}"'] & \tia \times Z \arrow[d, "\pi_Z"]                                      \\
                                                        & Z                                                                 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

Extension of paramorphisms, i.e, $$para(\phi) = zygo(Fix, \phi)$$

*** Histomorphism (on annotations)                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{\tfun{\tia}} \arrow[d] \arrow[r]                       & {\tfun{\tcfcm}} \arrow[d, "{\beta \circ \langle id, \phi \rangle}"] \\ 
\tia \arrow[u] \arrow[r] \arrow[rd, "histo(\phi)"'] & \tcfcm \arrow[d, "\alpha"]                                      \\
                                                             & A                                                                       
\end{tikzcd}
#+END_EXPORT 
#+END_CENTER
 

Builds computations of annotations $\tcfcm$ of a structure $\tia$
through $\phi: \tfun{\tcfcm} \mto A$ which inspects previous computations
in $\tfun{\tcfcm}$ to build the new $A$. E.g., for Fibonacci:

\begin{equation}
f(q) = \begin{cases}
 0 & \text{for } q = Z \\ 
 1 & \text{for } q = S (AnnF (Zero, ...)) \\ 
 n+m & \text{for } q = S (AnnF (S (AnnF, n), m)) \\ 
 \end{cases}
\end{equation}


*** Expression data types as initial alg. of functors               :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Two ways to build them, 

1. recursive data type which needs an explicitly recursive function to interpret it.

  #+BEGIN_EXAMPLE
  data Exp = Const Int | Neg Exp | Add Exp Exp 
  #+END_EXAMPLE

- Using a non-recursive data type
  
  #+BEGIN_EXAMPLE
  data ExprF e = Const Int | Neg e | Add e e deriving functor
  type Expr = Fix ExprF
  #+END_EXAMPLE

  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  1 \arrow[r, "const"] & {ExprF[Expr]} \arrow[d, "Fix"] \arrow[r] & {ExprF[Int]} \arrow[d, "rules"] \\
  Expr \times Expr \arrow[ru, "Add", bend left=49] & Expr \arrow[r, "eval"] \arrow[u, "Neg", bend left=60] & Int
  \end{tikzcd}
  #+END_EXPORT

  Build expressions in ~Expr~ with original type constructors, evaluate with ~eval
  = cata rules~.

*** Expression data types as functors - templating (free monad)     :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{A + \tfun{\tfm}} \arrow[d, "Fix_M", no head] \arrow[r]       & {A+\tfun{\tia}} \arrow[d, "\phi + Fix_T"] \\
\tfm \arrow[r, "\kappa(\phi + Fix_T)"'] & \tia                                 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- Assume $\tia$ is an initial algebra representing an AST of expressions built with $t$. $\tfm$ 
  is an initial algebra for $A + t[-]$.

- Then the fixed point $\tfm$ of $(A + t[-])$ is such that $\tfm$ is a tree similar to $\tia$
  where leafs are $A$ while $T$ merges them into the tree itself. 
- For templating consider $A=String$ referencing the name of a variable, given
  $\phi: A \rightarrow \tia$ you can build a complete $\tia$ with $\kappa(\phi +
  Fix_T)$ (acting as /template substitution/).

*** Expression data types as functors - annotation (cofree comonad) :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{A \times \tfun{\tcfcm}} \arrow[d, "\beta", no head] \arrow[r] & {A \times \tfun{\tia}} \arrow[d, "{\phi = Fix_T \circ snd}"] \\
\tcfcm \arrow[r, "\kappa(\phi)"']                          & \tia                                                         
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- $\tcfcm$ is an initial algebra as well. $\beta = Fix \circ AnnF$ here and in other slides;
  As the free monad, it can give back the original $\tia$.

- Useful because it can reuse $t$ algebras (e.g., printing) 

- the fixed point $\tcfcm$ is a tree similar to $\tia$ where all nodes have been annotated with
  values of type $A$

- In the above example one can strip annotations by running a $\kappa(\phi)$.


*** Expression data types as functors - adding annotations bottom-up :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{\tfun{\tia}} \arrow[r] \arrow[d, no head] & {\tfun{\tcfcm}} \arrow[d, "{\phi = \beta \circ \langle id, f \circ T\alpha\rangle}"] &   \\
\tia \arrow[r, "\kappa(\phi)"]         & \tcfcm \arrow[r, "\alpha"]                                                       & A
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- Assume $\alpha$ allows to get an annotation from the root of the tree
  $\tcfcm$ and $f: \tfun{A} \mto A$ is a $t$ algebra that allows to
  compute a new $A$ from the set of underlying tree's $A$; 
  $\beta: \tfun{\tcfcm} \times A \mto \tcfcm$ allows to build a new
  tree from child trees and an annotation.
- then $\kappa \phi$ can be used to annotate a tree (see $histo(f \circ T\alpha)$); for example $f = (+1) \circ
  sum_T$ can be used to annotate a root with the sum of $T$ childs (bottom-up
  annotation).


*** Expression data types as functors - evaluating into a monad     :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:
Useful to attach monadic actions to expressions; in general you would need an
algebra ~f (m a) -> m a~ but that would be difficult to specify. You can do
instead with ~algM: f a -> m a~, using ~cataM~ instead of ~cata~ and using kleisli
arrow composition.
#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{\tfun{\tia}} \arrow[d, no head] \arrow[rr] & *                           & {M[tA]} \arrow[d, "algM: tA \rightarrow MA", dashed, tail] \\
\tia \arrow[rr, "\kappa M(algM)"']      & * \arrow[u, "mapM", dotted] & MA                                                        
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

: eval' :: Env -> Expr -> Maybe Int
: eval'env = ('runReaderT' env) . cataM algM where
:   algM :: ExprF Int -> ReaderT Env Maybe Int
:   algM (Const c) = return c
:   algM (Var i) = ask >>= lift . M.lookup i

*** Parser combinators                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

- A /parser/ of A ($P[A]$), is an object $A^S$ which takes a string (type $S$) and returns a value $A$.

- A parser combinator, is a /higher order function/ that takes two or more parsers
  and returns a new parser (e.g., $alt: P[A]\times P[B] \rightarrow P[A+B]$ and
  $seq: P[A]\times P[B] \rightarrow P[A\times B]$):

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \begin{tikzcd}
  A^S \times B^S \arrow[d, "alt"] & A^S \times B^S \arrow[d, "seq"] \\
  (A+B)^S & (A \times B)^S
  \end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

- $P[A]$ is a functor in $A$; You can get a parser $PB$ for object $B$ if you have $P[A]$ and $A \rightarrow B$.

*** Expression data types as functors - parsers (annotation)        :focus:
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

Each constructor in $t$, e.g., $n_2: X \times X \mto t[X]$ can be made into a
parser of annotated trees by introducing a function $inj$ that, from a tree
parser creates an annotated tree parser.

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
\begin{tikzcd}
{P[\tcfcm] \times P[\tcfcm]} \arrow[d] \arrow[rr, "{P[n_2]}"] &  & {P[\tfun{\tcfcm}]} \arrow[d, "inj"]           \\
{P[\tcfcm]}     &  & {P[A \times \tfun{\tcfcm}]} \arrow[ll, "{P[fix]}"]
\end{tikzcd}
  #+END_EXPORT
  #+END_CENTER

*** Co-algebra                                                                 :noanki:
    Given a polynomial (endo-)functor $T$ that maps $X \in C$ to $T(X) \in
    C$, a functor co-algebra for $T$ is a pair $(U, c)$

    - an object $U \in C$ (*carrier*)
    - a morphism $c: U \rightarrow T(U)$ (*co-algebra structure*)

    $c$ must be defined by a tuple of several functions whose signature is
    specified by $T$. For example, $$T(X) = A \times X$$ defines $$(value,next):
    (U \rightarrow A, U \rightarrow U)$$ for any process $U$.
*** Homomorphisms of co-algebras                                                                 :noanki:

    Given two T-functor co-algebras $(U, a: - \rightarrow T(-))$ and $(V, b: - \rightarrow T(-))$,
    a homomorphism of algebras from $(U,a)$ to $(V,b)$ is a function $f: U \rightarrow V$ which commutes
    with the operations $$ T(f) \circ a = b \circ f$$
*** Final co-algebra                                                                 :noanki:
    - A final coalgebra $d: W \rightarrow T(W)$ is a coalgebra such that for
      every coalgebra $c: U \rightarrow T(U)$ there exists a unique map of
      co-algebras $f: (U,c) \rightarrow (W,d)$


*** Examples of final co-algebras                                                                  :focus:
    
    | Functor            | FC Carrier                        | FC Structure         | Notes                 |
    |--------------------+-----------------------------------+----------------------+-----------------------|
    | $A \times X$       | $A^\mathbb{N}$                    | head($a$), tail($a$) | Infinite lists of As  |
    | $1 + (A \times X)$ | $A^{\infty} = A^* + A^\mathbb{N}$ | possnext($a$)        | Finite and inf. lists |
    | $1 + X$            | $\mathbb{N} \cup \{ \infty \}$    | pred($n$)            |                       |
    
*** Bisimulation (for lists)                                                                  :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
S \arrow[d, "\xi"] & R \arrow[r, hook] \arrow[l, "\pi_1"] \arrow[d, "\gamma"] \arrow[l, "\pi_2"', bend right] & S \times S \\
A \times S         &  A \times R  \arrow[l]                                                                   &           
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

    - Assume a co-algebra $\xi: S \mto A \times S$ and $\pi_1, \pi_2$ are the
      projections from $R$ is called *a bi-simulation* if there exists
      $\gamma$ for which the above commutes for both $\pi_1$ and $\pi_2$.
    - If $S$ is a final co-algebra, e.g., a list $\xi = [h,t]$ then $\pi_1(a,b),
      \pi_2(a,b)$ must map to the same list $a=b$ so $R$ is an equivalence. For
      this to hold, one must find $\gamma$ for which:
      #+BEGIN_EXPORT latex
      \begin{align*}
      (\gamma_A(l_1,l_2), \gamma_{R,1}(l_1,l_2)) & = (h(l_1),t(l_1)) \\ 
      (\gamma_A(l_1,l_2), \gamma_{R,2}(l_1,l_2)) & = (h(l_2),t(l_2))
      \end{align*}
      #+END_EXPORT
      an indirect way to derive $\gamma$ would be to demonstrate that $h(l_1) =
      h(l_2) \wedge (t(l_1), t(l_2)) \in R$

*** Anamorphisms                                                                  :focus:
   - Given a final co-algebra A, and a generic co-algebra $(B,f)$ the unfold of
     $f$ allows to create a mapping $B \rightarrow A$ non-recursively; this is called $ana(f)$.

   - Anamorphisms are called co-recursion.

*** Streams as co-inductive data types (generation)                 :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

A stream $S_A$ is a final co-algebra of $s \mapsto a \times s$. One can build a stream from
a seed value $a \in A$ by using $ana([Id,\nu])$ where $\nu$ specifies how to 
generate the next value.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A \times A \arrow[rr, "Id \times \phi"]                          &  & A \times S_A \arrow[d, "scons = -_A \cdot -_{S_A}", bend left] \\
A \arrow[rr, "{\phi = \alpha([Id,\nu])}"] \arrow[u, "{[Id, \nu]}"] &  & S_A \arrow[u, "cofix"]                                        
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

We have that $\phi(a) = scons(a, \phi(\nu(a)) = a \cdot \nu(a) \cdot \nu^2(a) \cdot \ldots$

*** Streams as co-inductive data types (transformation)             :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:


#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
A \times S_A \arrow[rr, "Id \times \alpha(\nu)"]   &  & A \times S_A \arrow[d, "scons = -_A \cdot -_{S_A}", bend left] \\
S_A \arrow[rr, "\phi={\alpha(\nu)}"] \arrow[u, "{\nu}"] &  & S_A \arrow[u, "cofix"]                                        
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

$\nu$ can be lifted into a stream transformer:  $\phi(s) = \nu_A(s) \cdot \phi(\nu_S(s))$, for
example $\nu(s)= \langle (head(s))+1, tail(s) \rangle$ adds one to the stream.
** Free monads
*** Free monads (construction)                                      :focus:
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:
#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{A + \tfun{\tfm}} \arrow[d] \arrow[r] & {A+\tfun{X}} \arrow[d] \\
\tfm \arrow[u, "{\pi + \phi}"] \arrow[r] & {X}
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

 - The *free monad* $\tfm$ is the fixed point of a functor
   where $Fix = \pi + \phi$ (pure and free).

*** Free monads (bound function)                                    :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{\tfun{\tfmx{A}}} \arrow[r, "\phi"] \arrow[d, "Tf^o"] & {\tfm} \arrow[d, "f^o", red] \arrow[r, "\pi"] & A \arrow[ld, "f", dashed] \arrow[l] \\
{\tfun{\tfmx{B}}} \arrow[r, "\phi"] & {\tfmx{B}}  & 
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

- binding a function $f$ (i.e., $f^o$) depends on whether its argument comes
  from a pure $\pi$ or a free $\phi$: $$f^o = \begin{cases} f \circ \pi^{-1}
  \\ \phi\circ Tf^o \phi^{-1}\\ \end{cases}$$

*** Free monads (underlying commands from functor)                  :focus:

- Assume $C$ is the type of some sequence of commands; the functor represents
  the composition of one action with that sequence $$T[C] = (S \times
  C)_{print} + (S \mto C)_{getline} + 1_{end}$$

  #+BEGIN_CENTER
  #+BEGIN_EXPORT latex
  \includegraphics[width=4cm]{/Users/zaccaria/development/github/org-institutional/anki-cards/key/page-4-crop.pdf}
  #+END_EXPORT
  #+END_CENTER

- It is a way to build backwards a sequence of commands, e.g., $$getline~(x
  \mapsto (print~("hi" x) (end))) ~~~ : T[T[T[C]]]$$
 
*** Free monads (building monad commands from functor ones)         :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

Remember that $\tfun{A}$ is a sequence of commands. To build the
AST tree through a Free monad, e.g., ~type Console = Free ConsoleF~, we need to
lift single commands as they were sequences of one command alone.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
{\tfun{\tfm}} \arrow[d, "\phi"] & {\tfun{A}} \arrow[l, "\tfun{\pi}"] \arrow[ld, "liftF"] \\
{\tfm}                      &                                             
\end{tikzcd}
#+END_EXPORT
#+END_CENTER 

: tell :: String -> Console ()
: tell s = liftF (PutStrLn s ())
: 
: getline :: Console String
: getline = liftF (GetLine id)


*** Free monads (composition)                                       :focus:
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

Given two functors $T$ and $G$, one can build a free monad of $(T+G)$ 

: data (f :+: g) a = Inl f a | Inr g a
: instance (Functor f, Functor g) => Functor (f :+: g) where
:   fmap k (Inl fa) = fmap k fa 
:   fmap k (Inr ga) = fmap k ga

This is a way to compose functors which manage different effects into a single
monad.

*** Free monads (interpretation)                                    :focus:
    :PROPERTIES:
    :BEAMER_opt: fragile
    :END:

An interpreter $\iota$ is a morphism between the free monad $\tilde{F}_T^A$ and
a generic monad $M[A]$. It can be built through $\nu$ for which an appropriate
functor $\tilde{F}$ must be provided (it is always possible to build $\mu$). The
functor $\tilde{F}$ must abide the laws on the right for any $\nu$.

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
                                                                        &                                & A \arrow[rrd, "\pi_M", bend left] \arrow[d, "\pi_T"']      &                                     &                                        \\
\tilde{F}_T^A \arrow[rd, "\iota"', dashed] \arrow[r, "\tilde{F}_{\nu}"] & \tilde{F}_M^A \arrow[d, "\mu"] & \tilde{F}_T^A \arrow[rr, "\tilde{F}_{\nu}"']               &                                     & \tilde{F}_M^A                          \\
{T[A]} \arrow[r, "\nu", two heads, dashed]                              & {M[A]}                         & {T[\tilde{F}_T^A]} \arrow[u, "\phi_T"] \arrow[r, "TF_\nu"] & {T[\tilde{F}_M^A]} \arrow[r, "\nu"] & {M[\tilde{F}_M^A]} \arrow[u, "\phi_M"]
\end{tikzcd}
#+END_EXPORT
#+END_CENTER


(consistent with Tweagio's, check for Hopkins's free monad)

*** Suspended computation and continuation monads                   :focus:
    - A function ~(a -> r) -> r~ is called a suspended computation (SC). It needs a way
      to transform its intermediate value ~a~ into its final result ~r~.
    - Such a way is provided by means of a continuation ~a -> r~.
    - SCs form an endofunctor $Hom(Hom(-,R),R)$; this endofunctor can be made
      into a monad where a new ~SC b~ can be built from an ~SC a~ by specifying ~a ->
      SC b~ (bind).
* Logic,computation theory, dependent types
** Dependent types
*** Dependent pair

- Pair of two terms $(a,b)$ where $a: A$ and $b: B_a$. 
- Also called dependent sum because its type can be seen as

  $$(a,b) : \{a_1\} \times B_{a_1} + \{a_2\} \times B_{a_2} \ldots = \sum_{x:A} B_x$$

*** Existential type

Let us now assume that

- $\{ a_i \}$ is the type of the witness that $a_i$ exists.
- $B_{a_i}$ is the type of the witnesses for a proposition that depends on $a_i$.

then the expression of the dependent pair:

$$(a,b) : \{a_1\} \times B_{a_1} + \{a_2\} \times B_{a_2} \ldots $$

can be interpreted in logic as

$$(\exists a_1 \wedge B_{a_1}) \vee  (\exists a_2 \wedge B_{a_2}) \ldots \sim \exists x.B(x)$$

Which explains why dependent pairs are used to express existentially quantified
predicates.

*** Dependent pair example in Haskell

#+BEGIN_EXAMPLE
type family   B (x :: Bool)
type instance B 'True = Int
type instance B 'False = String

data BoolPair where
  (:*:) :: forall x. Sing x -> B x -> BoolPair

f :: BoolPair -> String
f (STrue :*: n) = show n
f (SFalse :*: s) = s
#+END_EXAMPLE

- ~Bool~ is a kind which corresponds to a set of two sets (types) ~'True~ and
  ~'False~. We can't however pattern match on those. To enable matching they 
  must be mapped to a singleton type with is own value constructor.

*** Dependent product

A dependent product is a function from a value $a : A$ into a value $b: B(a)$:
$$ \lambda x.\Phi : \Pi_{x:A} B_x $$ 

- If $A = \{ x_1 \}$ were a singleton type the function would have a constant
  type: $B_{x_1}^{\{x_1\}}$.

- If $A$ were more than one element we would end up with: $$ \Pi_{x:A} B_x =
  B_{x_1}^{\{x_1\}} \times B_{x_2}^{\{x_2\}} \times \ldots $$ 

- If $B$ were constant, we would obtain a simple exponential $$B^{\sum x_i} \sim
  B^A$$
*** Fixed point                                                     
:PROPERTIES:
:BEAMER_opt: fragile
:END:

A fixed point $\bar{x}$ of a function $f$ is such that the following commutes:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
X \arrow[r, "f"]                             & X \\
1 \arrow[u, "\bar{x}"] \arrow[ru, "\bar{x}"] &  
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

*** Fixed point combinator                                          :focus:
:PROPERTIES:
:BEAMER_opt: fragile
:END:

When $f$ is interpreted as a function between functions $(X^N)^{X^N}$, 
the fixed point is another function $\phi \in X^N$ such that 
the below commutes:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\begin{tikzcd}
\{ \phi \in X^N \} \arrow[r, "f"]                                                     & X^N \\
\{ f \in (X^N)^{X^N}  \simeq X^{X^N \times N} \} \arrow[u, "fix"] \arrow[ru, "fix"] &    
\end{tikzcd}
#+END_EXPORT
#+END_CENTER

For example, if $f \gamma n = (n>0)~?~(n*\gamma(n-1))~1$, then $$fix~f= f~(fix~
f)~~~\simeq~~~\phi~n = (n>0)~?~(n*\phi(n-1))~1$$

For languages that do not support recursion but only higher order functions, 
there is an explicit lambda representation for $fix$ found by H.Curry.

** Logic 
*** Classical logic                                                 :focus:
- it is /truth functional/, i.e., every complex proposition truth's is function of
  the truth of inner proposition, regardless of the fact that we can find
  witnesses for them.

- In classic logic the following is a valid argument $$\neg(\forall x,
  \neg P(x)) \vdash \exists x.P(x)$$ This depends on the principle of the
  third excluded which is not a valid rule in, for example, constructive logic.

*** Intuitionistic logic                                            :focus:
- Intuitionistic logic is /proof functional/, i.e., a proposition is  
  true if I can find a proof for it. 

- An existential can only be proven if I provide a witness: $$P(a) \vdash
  \exists x.P(x)$$

- It is classic logic without some axioms, for example $A \vee \neg A$ is not
  a valid axiom in .

*** Structural proof theory                                        :focus:
- It studies the validity of an argument $X \vdash Y$ from its structure

- An argument and a proof of its validity is a *theorem*.

- A valid argument with no premises is a *law* (or *axiom*).

*** Proof theory as a monoidal theory                               :focus:
 - Given an argument $X \vdash Y$, the proof of its validity is seen as the
   existence of one morphism between objects $X$ and $Y$. $X \vdash Y$ is then
   understood as the homset of morphisms from $X$ to $Y$.

 - $X \implies Y$ is an object corresponding to the set of
   equivalence classes of proofs from $X$ to $Y$. $X \otimes Y$ is the
   proposition $X \wedge Y$.

 - An *inference rule* specifies the validity of the inferred argument from that
   of the premises. It is a *morphism between homsets* which is always present.

*** Monoidal proof theory inference rules                           :focus:
   
   #+attr_latex: :font \footnotesize :width 0.85\linewidth :float t :placement [h]
   | CC name     | Logic name   | Inference rule                                      |
   |             |              |                                                     |
   | composition | cut          | \infer{X \vdash Z}{X \vdash Y & Y \vdash Z}         |
   |             |              |                                                     |
   | identity    | identity     | \infer{X \vdash X}{}                                |
   |             |              |                                                     |
   | Currying    |              | \infer{Y \vdash X \implies Z}{X \otimes Y \vdash Z} |
   |             |              |                                                     |
   |             | Modus ponens | \infer{X \otimes (X \implies Y) \vdash Y}{}         |
 
*** Structural proof theory examples                               :noanki:

- The most widespread are: Hilbert's calculi, Gentzen natural deduction, Gentzen sequent calculus

- Not very widespread: syllogistic calculus (Aristotle)

*** Hilbert calculi                                                 :focus:

- Used for up to first order logic
- Many axioms schemes, where each scheme is a template, e.g., 
  $\vdash \phi \mto \phi$ can mean $\vdash p \mto p$ or $\vdash (p \mto p) \mto (p \mto p)$
- one inference rule $$\infer{(X, X \mto Y) \vdash Y}{}$$
- Every line is an unconditional tautology.
- classic logic has an axiom scheme $\vdash (\neg \phi \mto \neg \psi) \mto (\phi \mto \psi)$ while  
  intuitionistic doesn't.

*** Gentzen sequent calculus                                        :focus:
- few axioms, many inference rules. 
- Introduces the concept of sequent: $$ X_1, \ldots X_n \vdash Y_1 \ldots Y_m $$
  which is a proposition that is read as: all of $X_i$ can be used to derive the truth 
  of at least one of $Y_j$
- Every line is a conditional tautology with zero or more conditions
- Every (conditional) line has zero or more asserted propositions on the right.

*** Natural deduction                                               :focus:
- It is a sequent calculus where every (conditional) line has exactly one
  asserted proposition on the right.

*** $\wedge$ introduction
- It is a valid inference rule for natural deduction 
  $$\{ A, B \} \vdash A \wedge B$$
  or $$\infer{A \wedge B}{A & B}$$

- Example of application $\{ A, B, C \} \vdash A \wedge B \wedge A \wedge C$: 
  $$ \infer{A \wedge B \wedge A \wedge C}{\infer{A \wedge B}{A & B & C} & \infer{A \wedge C}{A & B & C}} $$

*** $\wedge$ elimination

- It is a valid inference rule for natural deduction 
  $$ A \wedge B \vdash A$$

- Example for $Q =  (A \wedge B) \wedge C$

  #+BEGIN_EXPORT latex 
  \begin{equation}
  \infer{A \wedge (B \wedge C)}
    { 
      \infer{A}{\infer{A \wedge B}{Q}} & 
      \infer{B \wedge C}{
        \infer{B}{\infer{A \wedge B}{Q}} &
        \infer{C}{Q}
      }
    }
  \end{equation}
  #+END_EXPORT
*** $\implies$ introduction                                        

One can always introduce an implication of $B$ if one has $B$.

  #+BEGIN_EXPORT latex 
  \begin{equation}
  \infer{A \implies B}{B}
  \end{equation}
  #+END_EXPORT

*** $\vee$ introduction and elimination                             

Introduction

  #+BEGIN_EXPORT latex 
  \begin{equation}
  \infer{A \vee B}{B}
  \end{equation}
  #+END_EXPORT

Elimination

  #+BEGIN_EXPORT latex 
  \begin{equation}
  \infer{C}{A \vee B & \infer*{C}{[A]} & \infer*{C}{[B]}}
  \end{equation}
  #+END_EXPORT


*** Negation introduction and elimination                           

Negation introduction states that if a given antecedent implies both the
consequent and its complement, then the antecedent is a contradiction.

#+BEGIN_EXPORT latex
\begin{equation}
\infer{\neg C} { C \implies Q & C \implies \neg Q }
\end{equation}
#+END_EXPORT

Negation elimination is valid only in classical logic through double negation
#+BEGIN_EXPORT latex
\begin{equation}
\infer{C}{ \neg \neg C }
\end{equation}
#+END_EXPORT
This is exactly the rule of the excluded middle that was argued by Brower
in 1907.

*** Boolean algebra                                                 :focus:
It is a lattice where every element $a$ has /complement/ $\bar{a}$, i.e., such
that $$a \vee \bar{a} = 1$$ and $$a \wedge \bar{a} = 0$$
and where meets and joins are distributive.

*** Heyting algebra                                                 :focus:
 - A Heyting algebra is a bounded lattice with exponential objects $X \implies Y$
 - It is a Boolean algebra minus the complement for $\vee$.
 - The set of propositions $P$ with implication as morphisms is a Heyting Algebra
   because:
   - $X \wedge Y$ behaves as  the product and $\top$ is the terminal object.
   - the proposition $X \implies Z$ is another object and is such that is such
     that
      #+BEGIN_EXPORT latex
      \begin{equation}
      \textrm{hom}(X \wedge Y, Z) \cong \textrm{hom}(Y, X \implies Z)
      \end{equation}
      #+END_EXPORT 
   - $C^{op}$ with $\vee$ and $\bot$ is cartesian as well.
** Computation theory
*** Lambda calculus (application and abstraction)                   
- Programs are data; all data is a $\lambda$ term. 
- Basic terms are variables (countable set), e.g., "x", "y"...
- If $f$ and $t$ are terms, $f(t)$ is a term (/application/)
- If $x$ is a variable and $t$ is a term, then $(\lambda x .t)$ is a term (/lambda/-abstraction)

From a simple set of rules, Church and Kleene were able to build up Boolean
logic, the natural numbers, the usual operations of arithmetic, and so on. All
computable functions $f: N \mto N$ can be defined in the lambda calculus

*** Lambda calculus (beta and eta reduction)                        
If we apply $\lambda x.t$ to $s$ we get back $t$ but with $s$ substituted for
each free occurrence of $x$: $$(\lambda x.t)(s) = t[s/x]$$
This is a rewrite rule (beta reduction); by repeatedly applying it we perform *computation*.
Eta reduction says instead that one can always rewrite $$(\lambda x. t(x)) = t$$
Alpha conversion allows to rename the bound variable, e.g., $x$ in $\lambda x.t$.

*** Lambda calculus (Church numerals)                               :focus:
If we define: 
- $0 = \lambda f. \lambda x.x$
- $1 = \lambda f. \lambda x. f (x)$
- $2 = \lambda f. \lambda x. f(f (x))$
then $$ (\lambda a.(\lambda b.(\lambda x.a(b(x)))))$$ can define multiplication
by repeatedly applying rewrite rules.
*** Typed lambda calculus                                           :focus:
When types are added to lambda calculus, terms (programs) can be seen as
morphisms in a cartesian closed category where data types are objects.

- A term from $X$ to $Y$ is an element of $Y^X$ which is a function type.
  Since two terms might be actually the same morphism by rewrite rules, this
  must be intended as a set of equivalence classes under beta reduction.

- A product type is a pair of two types and there is also a terminal object
  (unit type) with only one element.

* Cryptography, quantum, probability, statistics
** Quantum computing                                                 
*** Pauli matrices                                                  :focus:
#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=1\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_pauli.pdf}
#+END_EXPORT
#+END_CENTER

*** Hilbert space $C^n$ - inner product                             :focus:

$C^n$ is an Hilbert space where the inner product is defined by:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=1\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_hilb.pdf}
#+END_EXPORT
#+END_CENTER

The inner product of two vectors is equal to the vector inner product between two matrix representations of those vectors.

*** Hilbert space $C^n$ - outer product                             :focus:

Remember that $\braket{v}{v'}$ is a complex number. The outer product operator
$\ketbra{w}{v}$ is a matrix defined as:

$$(\ketbra{w}{v})\ket{v'} = \braket{v}{v'}\ket{w}$$

If $\ket{i}$ is an orthonormal basis, we have that (/completeness relation/):
$$\sum_i \ketbra{i}{i} = I$$

Examples for orthonormal bases $\ket{0}$: 
#+BEGIN_EXPORT latex
\begin{equation}
\ketbra{0}{0} = \left (
\begin{array}{cc}
1& 0 \\
0 & 0 \\
\end{array}
\right ), 
\ketbra{1}{1} = \left (
\begin{array}{cc}
0& 0 \\
0 & 1 \\
\end{array}
\right ), 
\end{equation}
#+END_EXPORT




*** Eigenvectors and eigenvalues                                    :focus:
Given an operator $A$, its eigenvector $\ket{v}$ is such that
$$A \ket{v} = v \ket{v}$$ 
where $v$ is the eigenvalue of $A$ corresponding to $\ket{v}$ (note
that we will use the same name but the type is different.
Eigenvalues of $A$ can be found by solving $$c(v) = det | A - vI | = 0$$

*** Diagonal representation of an operator                          :focus:
An operator $A$ is diagonalizabile if it can afford a representation
in terms of outer products of eigenvectors:

$$A = \sum_i \lambda_i \ketbra{i}{i}$$

for example Pauli's $Z = \ketbra{0}{0} - \ketbra{1}{1}$ is thus diagonalizable.

*** Qubit
A qubit is something that has a state which, when measured can be either 0 with
probability $\alpha$ or 1 with probability $\beta$. We describe this state in 
a vector space of basis states: 

$$\ket{\phi} = \alpha \ket{0} + \beta \ket{1}$$

The norm of the vector must be always 1. 

*** Bloch sphere

The state of a qubit can be alternatively described with two parameters $\theta$ and $\phi$
which are the possible angles of the unit vector.

*** Bell state                                                      :focus:

A Bell state (EPR) pair is defined as: $$\ket{\beta_{00}} = \frac{\ket{00} + \ket{11}}{\sqrt{2}}$$
In a Bell state, if one measures only 1 of the two qubits, the other is determined.

*** Quantum gate                                                    :focus:

- A quantum gate operates on a set of qubits by a linear operation in the state
  vector space whose basis are the possible combinations of bits.

- This matrix $U$ must be such that $UU^+=I$ because they must preserve
  probability. Since unitary matrices are invertible, this means that
  all quantum gates must be reversible. 

- There are infinitely many two by two unitary matrices, properties of the
  complete set can be under- stood from the properties of a much smaller set
  called universal set.

*** Quantum not gate                                                :focus:

A 1 to 1 quantum gate swaps the basis states of a qubit: $$a\ket{0} + b\ket{1} \mto
a\ket{1} + b\ket{0}$$

*** Quantum Hadamard gate                                           :focus:

A 1 to 1 quantum gate that puts in superposition the basis states of a qubit:
$$a\ket{0} + b\ket{1} \mto a\frac{\ket{0} + \ket{1}}{\sqrt{2}} +
b\frac{\ket{0} + \ket{1}}{\sqrt{2}}$$

For example, applying $n$ Hadamard gates to $n$ qubits in the state $\ket{0}$ 
provides a final state of: $$H^{\otimes n}(\ket{0}) = \ket{0}^{\otimes n} = \frac{1}{\sqrt{2^n}}\sum_x \ket{x}$$

*** Quantum - Controlled not gate (CNOT)                            :focus:

It is a 2 qubit quantum gate which rotates values in the state vector space
with the following law: 

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.35\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_cnotgate.pdf}
#+END_EXPORT
#+END_CENTER


In practice, it inverts the components of $\ket{10}$ and $\ket{11}$. Any multiple
qubit gate can be composed by a CNOT and single qubit gates. If the state is a 
pure computational basis state $\ket{a,b}$ it is transformed into the basis
state $\ket{a, a \oplus b}$.

*** Quantum teleportation                                           :focus:

If two points $A$ and $B$ share a bell state, they can exchange quantum information
through classic bit communication:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.85\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_teleportation.pdf}
#+END_EXPORT
#+END_CENTER

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.55\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_teleportation_psi2.pdf}
#+END_EXPORT
#+END_CENTER


Which limits B's to 4 possible states after A performs measurements $M_1$ and
$M_2$. 

*** Toffoli gate                                                    :focus:

The Toffoli gate has three input bits and three output bits. Two of the bits are
control bits that are unaffected by the action of the Toffoli gate:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.35\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_toffoli.pdf}
#+END_EXPORT
#+END_CENTER

*** Ancilla state                                                   :focus:

It is a standard state prepared to create new gates, e.g., 1 is used in this Toffoli gate
to create a NAND gate:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.55\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_ancilla.pdf}
#+END_EXPORT
#+END_CENTER

*** Classic quantum parallelism (1 bit)                             :focus:

Assume $x$ the data register and $y$ the data register are both qubits and
define a unitary transformation $U_f:  \ket{x,y} \mto \ket{x,y \oplus f(x)}$. If the
data register is a superposition, the final state will be in a superposition as well

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.55\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_parallelism.pdf}
#+END_EXPORT
#+END_CENTER

I.e., $$\ket{\psi} = \frac{\ket{0,f(0)} + \ket{1,f(1)}}{\sqrt{2}}$$

*** Quantum parallelism ($n$ bit)                                   :focus:

Applying $n$ Hadamard gates to $n$ qubits in the state $\ket{0}$ 
provides a final state of: $$H^{\otimes n}(\ket{0}) = \ket{0}^{\otimes n} = \frac{1}{\sqrt{2^n}}\sum_x \ket{x}$$

If we apply a $U_f$ (where $f$ is an $n$ to $1$ bit function) to the state
$\ket{0}^{\otimes n}\ket{0}$, the resulting state is
$$\frac{1}{\sqrt{2^n}}\sum_x \ket{x}\ket{f(x)}$$

*** Quantum parallelism ($1$ bit) - Deutsch's algorithm             :focus:

With two additional hadamard gates with respect to the classic parallelism gate:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.55\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_deutsch.pdf}
#+END_EXPORT
#+END_CENTER

The first qubit of $\ket{\psi_3}$ will be proportional to $f(0) \oplus f(1)$ thus
allowing us to determine some global property of $f$ with just one evaluation of $f$.

*** Quantum parallelism ($n$ bit) - Deutsch-Josza algorithm         :focus:

#+BEGIN_CENTER
#+BEGIN_EXPORT latex
\includegraphics[width=0.55\linewidth]{/Users/zaccaria/development/github/org-institutional/anki-cards/images/q_deutsch_josza.pdf}
#+END_EXPORT
#+END_CENTER

The first $n$ qubits are $\sum_{\gamma} \widehat{f}(\gamma)\ket{\gamma}$. The
probability of measuring a $\ket{0...0}$ is $\widehat{f}(0)^2$, so, in the case
where $f$ can be either balanced or constant, we can distinguish the two
because, in the first case, one would never measure such state while in the
second case one would always measure such state.






** Probability and statistics
*** Kullback Leibler divergence                                     

Given two distributions $p(x)$ and $q(x)$, KL is defined as

$$D_q(p) = \sum_x p(x)\log_2\left(\frac{p(x)}{q(x)} \right)$$

Roughly, is a weighted average of the difference in terms of bits for the
encoding of a set of data following optimizied for $p$ and $q$ respectively.

*** Mutual information                                              

It is related to KL. It's the number of bits you save representing X and Y if
you understand the relationship between them instead of assuming they're
independent:

$$I(X,Y) = \sum_{x,y} p(x,y) \log_2\left(\frac{p(x,y)}{p(x)p(y)} \right)$$
